{"version":"0.2.8","files":{"/Users/kris/q-io/spec/fs/boot-directory-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":45,"total":45,"coverage":{},"source":"var FS = require(\"../../fs-boot\");\nvar normalize = FS.normal;\n\nvar specs = [\n    {\n        \"from\": \"foo\",\n        \"to\": \"\"\n    },\n    {\n        \"from\": \"\",\n        \"to\": \"..\"\n    },\n    {\n        \"from\": \".\",\n        \"to\": \"..\"\n    },\n    {\n        \"from\": \"..\",\n        \"to\": normalize(\"../..\")\n    },\n    {\n        \"from\": \"../foo\",\n        \"to\": \"..\"\n    },\n    {\n        \"from\": \"/foo/bar\",\n        \"to\": normalize(\"/foo\")\n    },\n    {\n        \"from\": \"/foo\",\n        \"to\": normalize(\"/\")\n    },\n    {\n        \"from\": \"/\",\n        \"to\": \"/\"\n    }\n];\n\ndescribe(\"fs-boot directory\", function () {\n    specs.forEach(function (spec) {\n        it(\"should parse \" + JSON.stringify(spec.from), function () {\n            expect(FS.directory(spec.from)).toBe(spec.to);\n        });\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"657dbb2f9fbcdf0c8930d0f764794dc9"},"/Users/kris/q-io/fs-boot.js":{"stats":{"percentage":0.8664495114006515,"lines":[{"lineno":19},{"lineno":44},{"lineno":82},{"lineno":119},{"lineno":120},{"lineno":121},{"lineno":122},{"lineno":123},{"lineno":124},{"lineno":125},{"lineno":127},{"lineno":128},{"lineno":129},{"lineno":130},{"lineno":131},{"lineno":133},{"lineno":134},{"lineno":135},{"lineno":136},{"lineno":138},{"lineno":139},{"lineno":140},{"lineno":141},{"lineno":143},{"lineno":147},{"lineno":151},{"lineno":155},{"lineno":156},{"lineno":157},{"lineno":237},{"lineno":248},{"lineno":249},{"lineno":250},{"lineno":251},{"lineno":289},{"lineno":290},{"lineno":301},{"lineno":302},{"lineno":303},{"lineno":304},{"lineno":307}],"missing":41,"seen":266,"total":307,"coverage":{"19":{"partial":false,"source":"    return str.replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\");","missing":[{"startCol":4,"endCol":59},{"startCol":11,"endCol":58}]},"44":{"partial":false,"source":"    exports.ALT_SEPARATOR = \"/\";","missing":[{"startCol":4,"endCol":32}]},"82":{"partial":false,"source":"        throw new Error(\"Cannot split \" + (typeof path) + \", \" + JSON.stringify(path));","missing":[{"startCol":8,"endCol":87},{"startCol":24,"endCol":55},{"startCol":65,"endCol":85}]},"119":{"partial":false,"source":"    var root = \"\";","missing":[{"startCol":4,"endCol":18}]},"120":{"partial":false,"source":"    var parents = [];","missing":[{"startCol":4,"endCol":21}]},"121":{"partial":false,"source":"    var children = [];","missing":[{"startCol":4,"endCol":22}]},"122":{"partial":false,"source":"    var leaf = \"\";","missing":[{"startCol":4,"endCol":18}]},"123":{"partial":false,"source":"    for (var i = 0; i < arguments.length; i++) {","missing":[{"startCol":20,"endCol":40},{"startCol":42,"endCol":45}]},"124":{"partial":false,"source":"        var path = String(arguments[i]);","missing":[{"startCol":8,"endCol":40},{"startCol":19,"endCol":39}]},"125":{"partial":false,"source":"        if (path == \"\")","missing":[{"startCol":12,"endCol":22}]},"127":{"partial":false,"source":"        var parts = path.split(exports.SEPARATORS_RE());","missing":[{"startCol":8,"endCol":56},{"startCol":20,"endCol":55},{"startCol":31,"endCol":54}]},"128":{"partial":false,"source":"        if (exports.isAbsolute(path)) {","missing":[{"startCol":12,"endCol":36}]},"129":{"partial":false,"source":"            root = parts.shift() + exports.SEPARATOR;","missing":[{"startCol":12,"endCol":53},{"startCol":19,"endCol":32}]},"130":{"partial":false,"source":"            parents = [];","missing":[{"startCol":12,"endCol":25}]},"131":{"partial":false,"source":"            children = [];","missing":[{"startCol":12,"endCol":26}]},"133":{"partial":false,"source":"        leaf = parts.pop();","missing":[{"startCol":8,"endCol":27},{"startCol":15,"endCol":26}]},"134":{"partial":false,"source":"        if (leaf == \".\" || leaf == \"..\") {","missing":[{"startCol":12,"endCol":23},{"startCol":27,"endCol":39}]},"135":{"partial":false,"source":"            parts.push(leaf);","missing":[{"startCol":12,"endCol":28}]},"136":{"partial":false,"source":"            leaf = \"\";","missing":[{"startCol":12,"endCol":22}]},"138":{"partial":false,"source":"        for (var j = 0; j < parts.length; j++) {","missing":[{"startCol":24,"endCol":40},{"startCol":42,"endCol":45}]},"139":{"partial":false,"source":"            var part = parts[j];","missing":[{"startCol":12,"endCol":32}]},"140":{"partial":false,"source":"            if (part == \".\" || part == \"\") {","missing":[{"startCol":16,"endCol":27},{"startCol":31,"endCol":41}]},"141":{"partial":false,"source":"            } else if (part == \"..\") {","missing":[{"startCol":23,"endCol":35}]},"143":{"partial":false,"source":"                    children.pop();","missing":[{"startCol":20,"endCol":34}]},"147":{"partial":false,"source":"                        parents.push(\"..\");","missing":[{"startCol":24,"endCol":42}]},"151":{"partial":false,"source":"                children.push(part);","missing":[{"startCol":16,"endCol":35}]},"155":{"partial":false,"source":"    path = parents.concat(children).join(exports.SEPARATOR);","missing":[{"startCol":4,"endCol":60},{"startCol":11,"endCol":59},{"startCol":25,"endCol":35}]},"156":{"partial":false,"source":"    if (path) leaf = exports.SEPARATOR + leaf;","missing":[{"startCol":14,"endCol":46},{"startCol":21,"endCol":45}]},"157":{"partial":false,"source":"    return root + path + leaf;","missing":[{"startCol":4,"endCol":30},{"startCol":11,"endCol":22}]},"237":{"partial":false,"source":"        return /[a-zA-Z]:$/.test(first);","missing":[{"startCol":8,"endCol":40},{"startCol":15,"endCol":39}]},"248":{"partial":false,"source":"    if (!exports.isAbsolute(path))","missing":[{"startCol":9,"endCol":33}]},"249":{"partial":false,"source":"        path = require(\"./fs\").absolute(path);","missing":[{"startCol":8,"endCol":46},{"startCol":15,"endCol":45},{"startCol":22,"endCol":30}]},"250":{"partial":false,"source":"    var parts = exports.split(path);","missing":[{"startCol":4,"endCol":36},{"startCol":16,"endCol":35}]},"251":{"partial":false,"source":"    return exports.join(parts[0], \"\");","missing":[{"startCol":4,"endCol":38},{"startCol":11,"endCol":37}]},"289":{"partial":false,"source":"        base = base.replace(","missing":[{}]},"290":{"partial":false,"source":"            new RegExp(regExpEscape(extension) + \"$\"),","missing":[{},{"startCol":23,"endCol":52}]},"291":{"partial":false,"source":"            \"\"","missing":[{}]},"292":{"partial":false,"source":"        );","missing":[{}]},"301":{"partial":false,"source":"    path = exports.base(path);","missing":[{"startCol":4,"endCol":30},{"startCol":11,"endCol":29}]},"302":{"partial":false,"source":"    path = path.replace(/^\\.*/, \"\");","missing":[{"startCol":4,"endCol":36},{"startCol":11,"endCol":35}]},"303":{"partial":false,"source":"    var index = path.lastIndexOf(\".\");","missing":[{"startCol":4,"endCol":38},{"startCol":16,"endCol":37}]},"304":{"partial":false,"source":"    return index <= 0 ? \"\" : path.substring(index);","missing":[{"startCol":4,"endCol":51},{"startCol":11,"endCol":21},{"startCol":24,"endCol":26},{"startCol":29,"endCol":50}]},"307":{"partial":true,"source":"})(typeof exports !== \"undefined\" ? exports : FS_BOOT = {});","missing":[{"startCol":46,"endCol":58}]}},"source":"(function (exports) {\n\n// -- kriskowal Kris Kowal Copyright (C) 2009-2010 MIT License\n// -- tlrobinson Tom Robinson TODO\n\n/**\n * Pure JavaScript implementations of file system path\n * manipulation.\n */\n\n// NOTE: this file may be used is the engine bootstrapping\n// process, so any \"requires\" must be accounted for in\n// narwhal.js\n\n/*whatsupdoc*/\n/*markup markdown*/\n\nvar regExpEscape = function (str) {\n    return str.replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\");\n};\n\nvar path = require(\"path\");\n\n/**\n * @name ROOT\n * * `/` on Unix\n * * `\\` on Windows\n */\n\n/**\n * @name SEPARATOR\n * * `/` on Unix\n * * `\\` on Windows\n */\n\n/**\n * @name ALT_SEPARATOR\n * * undefined on Unix\n * * `/` on Windows\n */\n\nexports.ROOT = exports.SEPARATOR = path.sep;\nif (path.sep === \"\\\\\") {\n    exports.ALT_SEPARATOR = \"/\";\n} else {\n    exports.ALT_SEPARATOR = undefined;\n}\n\n// we need to make sure the separator regex is always in sync with the separators.\n// this caches the generated regex and rebuild if either separator changes.\nvar separatorCached, altSeparatorCached, separatorReCached;\n/**\n * @function\n */\nexports.SEPARATORS_RE = function () {\n    if (\n        separatorCached !== exports.SEPARATOR ||\n        altSeparatorCached !== exports.ALT_SEPARATOR\n    ) {\n        separatorCached = exports.SEPARATOR;\n        altSeparatorCached = exports.ALT_SEPARATOR;\n        separatorReCached = new RegExp(\"[\" +\n            (separatorCached || \"\").replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\") +\n            (altSeparatorCached || \"\").replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\") +\n        \"]\", \"g\");\n    }\n    return separatorReCached;\n}\n\n/**\n * separates a path into components.  If the path is\n * absolute, the first path component is the root of the\n * file system, indicated by an empty string on Unix, and a\n * drive letter followed by a colon on Windows.\n * @returns {Array * String}\n */\nexports.split = function (path) {\n    var parts;\n    try {\n        parts = String(path).split(exports.SEPARATORS_RE());\n    } catch (exception) {\n        throw new Error(\"Cannot split \" + (typeof path) + \", \" + JSON.stringify(path));\n    }\n    // this special case helps isAbsolute\n    // distinguish an empty path from an absolute path\n    // \"\" -> [] NOT [\"\"]\n    if (parts.length === 1 && parts[0] === \"\")\n        return [];\n    // \"a\" -> [\"a\"]\n    // \"/a\" -> [\"\", \"a\"]\n    return parts;\n};\n\n/**\n * Takes file system paths as variadic arguments and treats\n * each as a file or directory path and returns the path\n * arrived by traversing into the those paths.  All\n * arguments except for the last must be paths to\n * directories for the result to be meaningful.\n * @returns {String} path\n */\nexports.join = function () {\n    if (arguments.length === 1 && Array.isArray(arguments[0]))\n        return exports.normal.apply(exports, arguments[0]);\n    return exports.normal.apply(exports, arguments);\n};\n\n/**\n * Takes file system paths as variadic arguments and treats\n * each path as a location, in the URL sense, resolving each\n * new location based on the previous.  For example, if the\n * first argument is the absolute path of a JSON file, and\n * the second argument is a path mentioned in that JSON\n * file, `resolve` returns the absolute path of the\n * mentioned file.\n * @returns {String} path\n */\nexports.resolve = function () {\n    var root = \"\";\n    var parents = [];\n    var children = [];\n    var leaf = \"\";\n    for (var i = 0; i < arguments.length; i++) {\n        var path = String(arguments[i]);\n        if (path == \"\")\n            continue;\n        var parts = path.split(exports.SEPARATORS_RE());\n        if (exports.isAbsolute(path)) {\n            root = parts.shift() + exports.SEPARATOR;\n            parents = [];\n            children = [];\n        }\n        leaf = parts.pop();\n        if (leaf == \".\" || leaf == \"..\") {\n            parts.push(leaf);\n            leaf = \"\";\n        }\n        for (var j = 0; j < parts.length; j++) {\n            var part = parts[j];\n            if (part == \".\" || part == \"\") {\n            } else if (part == \"..\") {\n                if (children.length) {\n                    children.pop();\n                } else {\n                    if (root) {\n                    } else {\n                        parents.push(\"..\");\n                    }\n                }\n            } else {\n                children.push(part);\n            }\n        };\n    }\n    path = parents.concat(children).join(exports.SEPARATOR);\n    if (path) leaf = exports.SEPARATOR + leaf;\n    return root + path + leaf;\n};\n\n/**\n * Takes paths as any number of arguments and reduces them\n * into a single path in normal form, removing all \".\" path\n * components, and reducing \"..\" path components by removing\n * the previous path component if possible.\n * @returns {String} path\n */\nexports.normal = function () {\n    var root = \"\";\n    var parents = [];\n    var children = [];\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n        var path = String(arguments[i]);\n        // empty paths have no affect\n        if (path === \"\")\n            continue;\n        var parts = path.split(exports.SEPARATORS_RE());\n        if (exports.isAbsolute(path)) {\n            root = parts.shift() + exports.SEPARATOR;\n            parents = [];\n            children = [];\n        }\n        for (var j = 0, jj = parts.length; j < jj; j++) {\n            var part = parts[j];\n            if (part === \".\" || part === \"\") {\n            } else if (part == \"..\") {\n                if (children.length) {\n                    children.pop();\n                } else {\n                    if (root) {\n                    } else {\n                        parents.push(\"..\");\n                    }\n                }\n            } else {\n                children.push(part);\n            }\n        }\n    }\n    path = parents.concat(children).join(exports.SEPARATOR);\n    return root + path;\n};\n\n/***\n * @returns {Boolean} whether the given path begins at the\n * root of the file system or a drive letter.\n */\nexports.isAbsolute = function (path) {\n    // for absolute paths on any operating system,\n    // the first path component always determines\n    // whether it is relative or absolute.  On Unix,\n    // it is empty, so [\"\", \"foo\"].join(\"/\") == \"/foo\",\n    // \"/foo\".split(\"/\") == [\"\", \"foo\"].\n    var parts = exports.split(path);\n    // split(\"\") == [].  \"\" is not absolute.\n    // split(\"/\") == [\"\", \"\"] is absolute.\n    // split(?) == [\"\"] does not occur.\n    if (parts.length == 0)\n        return false;\n    return exports.isRoot(parts[0]);\n};\n\n/**\n * @returns {Boolean} whether the given path does not begin\n * at the root of the file system or a drive letter.\n */\nexports.isRelative = function (path) {\n    return !exports.isAbsolute(path);\n};\n\n/**\n * @returns {Boolean} whether the given path component\n * corresponds to the root of the file system or a drive\n * letter, as applicable.\n */\nexports.isRoot = function (first) {\n    if (exports.SEPARATOR === \"\\\\\") {\n        return /[a-zA-Z]:$/.test(first);\n    } else {\n        return first == \"\";\n    }\n};\n\n/**\n * @returns {String} the Unix root path or corresponding\n * Windows drive for a given path.\n */\nexports.root = function (path) {\n    if (!exports.isAbsolute(path))\n        path = require(\"./fs\").absolute(path);\n    var parts = exports.split(path);\n    return exports.join(parts[0], \"\");\n};\n\n/**\n * @returns {String} the parent directory of the given path.\n */\nexports.directory = function (path) {\n    path = exports.normal(path);\n    var absolute = exports.isAbsolute(path);\n    var parts = exports.split(path);\n    // XXX needs to be sensitive to the root for\n    // Windows compatibility\n    if (parts.length) {\n        if (parts[parts.length - 1] == \"..\") {\n            parts.push(\"..\");\n        } else {\n            parts.pop();\n        }\n    } else {\n        parts.unshift(\"..\");\n    }\n    return parts.join(exports.SEPARATOR) || (\n        exports.isRelative(path) ?\n        \"\" : exports.ROOT\n    );\n};\n\n/**\n * @returns {String} the last component of a path, without\n * the given extension if the extension is provided and\n * matches the given file.\n * @param {String} path\n * @param {String} extention an optional extention to detect\n * and remove if it exists.\n */\nexports.base = function (path, extension) {\n    var base = path.split(exports.SEPARATORS_RE()).pop();\n    if (extension)\n        base = base.replace(\n            new RegExp(regExpEscape(extension) + \"$\"),\n            \"\"\n        );\n    return base;\n};\n\n/**\n * @returns {String} the extension (e.g., `txt`) of the file\n * at the given path.\n */\nexports.extension = function (path) {\n    path = exports.base(path);\n    path = path.replace(/^\\.*/, \"\");\n    var index = path.lastIndexOf(\".\");\n    return index <= 0 ? \"\" : path.substring(index);\n};\n\n})(typeof exports !== \"undefined\" ? exports : FS_BOOT = {});","blocks":{"total":54,"seen":31,"missing":23,"percentage":0.5740740740740741}},"hash":"e2af320eeb3cbab70ac93f92c34ae1ba"},"/Users/kris/q-io/spec/fs/issues/1-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":31,"total":31,"coverage":{},"source":"require(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n\ndescribe(\"write and remove\", function () {\n\n    it(\"should write and remove a file\", function () {\n\n        var fixture = FS.join(__dirname, \"fixture.txt\");\n\n        return FS.write(fixture, \"1234\")\n        .then(function (result) {\n            expect(result).toBe(undefined);\n        })\n\n        .then(function () {\n            return FS.remove(fixture);\n        })\n        .then(function (result) {\n            expect(result).toBe(undefined);\n        })\n\n        .then(function () {\n            return FS.exists(fixture)\n        })\n        .then(function (exists) {\n            expect(exists).toBe(false);\n        })\n\n    });\n});","blocks":{"total":7,"seen":7,"missing":0,"percentage":1}},"hash":"947436878d42ebecd4ba9e18e552009c"},"/Users/kris/q-io/spec/lib/jasmine-promise.js":{"stats":{"percentage":0.9024390243902439,"lines":[{"lineno":31},{"lineno":32},{"lineno":38},{"lineno":39}],"missing":4,"seen":37,"total":41,"coverage":{"31":{"partial":false,"source":"                spec.fail(error);","missing":[{"startCol":16,"endCol":32}]},"32":{"partial":false,"source":"                onComplete();","missing":[{"startCol":16,"endCol":28}]},"38":{"partial":false,"source":"        spec.fail(error);","missing":[{"startCol":8,"endCol":24}]},"39":{"partial":false,"source":"        onComplete();","missing":[{"startCol":8,"endCol":20}]}},"source":"\"use strict\";\n\nvar Q = require(\"q\");\n\n/**\n * Modifies the way that individual specs are run to easily test async\n * code with promises.\n *\n * A spec may return a promise. If it does, then the spec passes if and\n * only if that promise is fulfilled within a very short period of time.\n * If it is rejected, or if it isn't fulfilled quickly, the spec fails.\n *\n * In this way, we can use promise chaining to structure our asynchronous\n * tests. Expectations all down the chain of promises are all checked and\n * guaranteed to be run and resolved or the test fails.\n *\n * This is a big win over the runs() and watches() code that jasmine\n * supports out of the box.\n */\njasmine.Block.prototype.execute = function (onComplete) {\n    var spec = this.spec;\n    try {\n        var result = this.func.call(spec, onComplete);\n\n        // It seems Jasmine likes to return the suite if you pass it anything.\n        // So make sure it's a promise first.\n        if (result && typeof result.then === \"function\") {\n            Q.timeout(result, 500).then(function () {\n                onComplete();\n            }, function (error) {\n                spec.fail(error);\n                onComplete();\n            });\n        } else if (this.func.length === 0) {\n            onComplete();\n        }\n    } catch (error) {\n        spec.fail(error);\n        onComplete();\n    }\n};","blocks":{"total":7,"seen":5,"missing":2,"percentage":0.7142857142857143}},"hash":"e72b668dd4c4f55fae785bf5b9a21249"},"/Users/kris/q-io/fs.js":{"stats":{"percentage":0.7604166666666666,"lines":[{"lineno":29},{"lineno":35},{"lineno":36},{"lineno":37},{"lineno":39},{"lineno":65},{"lineno":68},{"lineno":76},{"lineno":95},{"lineno":96},{"lineno":105},{"lineno":106},{"lineno":107},{"lineno":110},{"lineno":111},{"lineno":112},{"lineno":114},{"lineno":116},{"lineno":117},{"lineno":118},{"lineno":120},{"lineno":129},{"lineno":137},{"lineno":138},{"lineno":156},{"lineno":157},{"lineno":172},{"lineno":173},{"lineno":199},{"lineno":230},{"lineno":234},{"lineno":235},{"lineno":237},{"lineno":239},{"lineno":240},{"lineno":242},{"lineno":246},{"lineno":248},{"lineno":252},{"lineno":253},{"lineno":255},{"lineno":257},{"lineno":258},{"lineno":260},{"lineno":264},{"lineno":266},{"lineno":270},{"lineno":271},{"lineno":272},{"lineno":274},{"lineno":276},{"lineno":277},{"lineno":279},{"lineno":283},{"lineno":285},{"lineno":297},{"lineno":298},{"lineno":300},{"lineno":301},{"lineno":302},{"lineno":303},{"lineno":305},{"lineno":307},{"lineno":308},{"lineno":310},{"lineno":314},{"lineno":316},{"lineno":320},{"lineno":321},{"lineno":323},{"lineno":325},{"lineno":326},{"lineno":328},{"lineno":332},{"lineno":334},{"lineno":338},{"lineno":339},{"lineno":340},{"lineno":342},{"lineno":344},{"lineno":345},{"lineno":347},{"lineno":351},{"lineno":353},{"lineno":360},{"lineno":361},{"lineno":370},{"lineno":371},{"lineno":373},{"lineno":374},{"lineno":376},{"lineno":379}],"missing":92,"seen":292,"total":384,"coverage":{"29":{"partial":true,"source":"        var ready = backOffDelay ? Q.delay(backOffDelay) : Q.resolve();","missing":[{"startCol":35,"endCol":56}]},"35":{"partial":false,"source":"                if (error.code === \"EMFILE\") {","missing":[{"startCol":20,"endCol":43}]},"36":{"partial":false,"source":"                    backOffDelay = (backOffDelay + 1) * backOffFactor;","missing":[{"startCol":20,"endCol":70},{"startCol":35,"endCol":53}]},"37":{"partial":false,"source":"                    return retry.apply(null, args);","missing":[{"startCol":20,"endCol":51},{"startCol":27,"endCol":50}]},"39":{"partial":false,"source":"                    throw error;","missing":[{"startCol":20,"endCol":32}]},"65":{"partial":false,"source":"        nodeOptions.bufferSize = options.bufferSize;","missing":[{"startCol":8,"endCol":52}]},"68":{"partial":false,"source":"        nodeOptions.mode = options.mode;","missing":[{"startCol":8,"endCol":40}]},"76":{"partial":false,"source":"            throw new Error(\"Can't open a binary file with a charset: \" + charset);","missing":[{"startCol":12,"endCol":83},{"startCol":28,"endCol":81}]},"95":{"partial":false,"source":"            error.message = \"Can't remove \" + JSON.stringify(path) + \": \" + error.message;","missing":[{"startCol":12,"endCol":90},{"startCol":28,"endCol":66},{"startCol":46,"endCol":66}]},"96":{"partial":false,"source":"            done.reject(error);","missing":[{"startCol":12,"endCol":30}]},"105":{"partial":false,"source":"    source = String(source);","missing":[{"startCol":4,"endCol":28},{"startCol":13,"endCol":27}]},"106":{"partial":false,"source":"    target = String(target);","missing":[{"startCol":4,"endCol":28},{"startCol":13,"endCol":27}]},"107":{"partial":false,"source":"    return exports.exists(target)","missing":[{"startCol":25,"endCol":33},{}]},"108":{"partial":false,"source":"    .then(function (exists) {","missing":[{}]},"109":{"partial":false,"source":"        if (exists) {","missing":[{}]},"110":{"partial":false,"source":"            var error = new Error(\"Can't move over existing entry \" + target);","missing":[{},{"startCol":12,"endCol":78},{"startCol":34,"endCol":76}]},"111":{"partial":false,"source":"            error.code = \"EEXISTS\";","missing":[{},{"startCol":12,"endCol":35}]},"112":{"partial":false,"source":"            throw error;","missing":[{"startCol":12,"endCol":24},{}]},"113":{"partial":false,"source":"        }","missing":[{}]},"114":{"partial":false,"source":"        return Q.ninvoke(FS, \"rename\", source, target)","missing":[{},{"startCol":24,"endCol":54}]},"115":{"partial":false,"source":"        .fail(function (error) {","missing":[{}]},"116":{"partial":false,"source":"            error.message = (","missing":[{}]},"117":{"partial":false,"source":"                \"Can't move \" + JSON.stringify(source) + \" to \" +","missing":[{},{"startCol":16,"endCol":54},{"startCol":32,"endCol":54}]},"118":{"partial":false,"source":"                JSON.stringify(target) + \" because \" + error.message","missing":[{},{"startCol":16,"endCol":38}]},"119":{"partial":false,"source":"            );","missing":[{}]},"120":{"partial":false,"source":"            throw error;","missing":[{},{"startCol":12,"endCol":24}]},"121":{"partial":false,"source":"        });","missing":[{}]},"122":{"partial":false,"source":"    });","missing":[{}]},"129":{"partial":false,"source":"        mode = parseInt(mode, 8);","missing":[{"startCol":8,"endCol":33},{"startCol":15,"endCol":32}]},"137":{"partial":false,"source":"                error.exists = true;","missing":[{"startCol":16,"endCol":36}]},"138":{"partial":false,"source":"                error.isDirectory = true;","missing":[{"startCol":16,"endCol":41}]},"156":{"partial":false,"source":"            error.message = \"Can't removeDirectory \" + JSON.stringify(path) + \": \" + error.message;","missing":[{"startCol":12,"endCol":99},{"startCol":28,"endCol":75},{"startCol":55,"endCol":75}]},"157":{"partial":false,"source":"            done.reject(error);","missing":[{"startCol":12,"endCol":30}]},"172":{"partial":false,"source":"            error.message = \"Can't list \" + JSON.stringify(path) + \": \" + error.message;","missing":[{"startCol":12,"endCol":88},{"startCol":28,"endCol":64},{"startCol":44,"endCol":64}]},"173":{"partial":false,"source":"            return result.reject(error);","missing":[{"startCol":12,"endCol":40},{"startCol":19,"endCol":39}]},"199":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"230":{"partial":false,"source":"    return new Date(this.node.atime);","missing":[{"startCol":4,"endCol":37}]},"234":{"partial":false,"source":"    path = String(path);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"235":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"237":{"partial":false,"source":"        FS.lstat(path, function (error, stat) {","missing":[{}]},"238":{"partial":false,"source":"            if (error) {","missing":[{}]},"239":{"partial":false,"source":"                error.message = \"Can't statLink \" + JSON.stringify(path) + \": \" + error.message;","missing":[{"startCol":32,"endCol":72},{"startCol":52,"endCol":72},{},{"startCol":16,"endCol":96}]},"240":{"partial":false,"source":"                done.reject(error);","missing":[{"startCol":16,"endCol":34},{}]},"241":{"partial":false,"source":"            } else {","missing":[{}]},"242":{"partial":false,"source":"                done.resolve(stat);","missing":[{},{"startCol":16,"endCol":34}]},"243":{"partial":false,"source":"            }","missing":[{}]},"244":{"partial":false,"source":"        });","missing":[{}]},"246":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"248":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"252":{"partial":false,"source":"    fd = Number(fd);","missing":[{"startCol":4,"endCol":20},{"startCol":9,"endCol":19}]},"253":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"255":{"partial":false,"source":"        FS.fstat(fd, function (error, stat) {","missing":[{}]},"256":{"partial":false,"source":"            if (error) {","missing":[{}]},"257":{"partial":false,"source":"                error.message = \"Can't statFd file descriptor \" + JSON.stringify(fd) + \": \" + error.message;","missing":[{},{"startCol":16,"endCol":108},{"startCol":32,"endCol":84},{"startCol":66,"endCol":84}]},"258":{"partial":false,"source":"                done.reject(error);","missing":[{"startCol":16,"endCol":34},{}]},"259":{"partial":false,"source":"            } else {","missing":[{}]},"260":{"partial":false,"source":"                done.resolve(stat);","missing":[{"startCol":16,"endCol":34},{}]},"261":{"partial":false,"source":"            }","missing":[{}]},"262":{"partial":false,"source":"        });","missing":[{}]},"264":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"266":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"270":{"partial":false,"source":"    source = String(source);","missing":[{"startCol":4,"endCol":28},{"startCol":13,"endCol":27}]},"271":{"partial":false,"source":"    target = String(target);","missing":[{"startCol":4,"endCol":28},{"startCol":13,"endCol":27}]},"272":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"274":{"partial":false,"source":"        FS.link(source, target, function (error) {","missing":[{}]},"275":{"partial":false,"source":"            if (error) {","missing":[{}]},"276":{"partial":false,"source":"                error.message = \"Can't link \" + JSON.stringify(source) + \" to \" + JSON.stringify(target) + \": \" + error.message;","missing":[{"startCol":16,"endCol":128},{"startCol":32,"endCol":70},{},{"startCol":48,"endCol":70},{"startCol":82,"endCol":104}]},"277":{"partial":false,"source":"                done.reject(error);","missing":[{"startCol":16,"endCol":34},{}]},"278":{"partial":false,"source":"            } else {","missing":[{}]},"279":{"partial":false,"source":"                done.resolve();","missing":[{},{"startCol":16,"endCol":30}]},"280":{"partial":false,"source":"            }","missing":[{}]},"281":{"partial":false,"source":"        });","missing":[{}]},"283":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"285":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"297":{"partial":false,"source":"    if (!linkTypes.hasOwnProperty(type)) {","missing":[{"startCol":9,"endCol":39}]},"298":{"partial":false,"source":"        console.warn(new Error(\"For Windows compatibility, symbolicLink must be called with a type argument \\\"file\\\", \\\"directory\\\", or \\\"junction\\\"\"));","missing":[{"startCol":8,"endCol":151}]},"300":{"partial":false,"source":"    type = linkTypes[type];","missing":[{"startCol":4,"endCol":27}]},"301":{"partial":false,"source":"    target = String(target);","missing":[{"startCol":4,"endCol":28},{"startCol":13,"endCol":27}]},"302":{"partial":false,"source":"    relative = String(relative);","missing":[{"startCol":4,"endCol":32},{"startCol":15,"endCol":31}]},"303":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"305":{"partial":false,"source":"        FS.symlink(relative, target, type || 'file', function (error) {","missing":[{"startCol":37,"endCol":51},{}]},"306":{"partial":false,"source":"            if (error) {","missing":[{}]},"307":{"partial":false,"source":"                error.message = \"Can't create symbolicLink \" + JSON.stringify(target) + \" to relative location \" + JSON.stringify(relative) + \": \" + error.message;","missing":[{"startCol":16,"endCol":163},{"startCol":32,"endCol":85},{"startCol":63,"endCol":85},{},{"startCol":115,"endCol":139}]},"308":{"partial":false,"source":"                done.reject(error);","missing":[{},{"startCol":16,"endCol":35}]},"309":{"partial":false,"source":"            } else {","missing":[{}]},"310":{"partial":false,"source":"                done.resolve();","missing":[{},{"startCol":16,"endCol":30}]},"311":{"partial":false,"source":"            }","missing":[{}]},"312":{"partial":false,"source":"        });","missing":[{}]},"314":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"316":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"320":{"partial":false,"source":"    path = String(path);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"321":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"323":{"partial":false,"source":"        FS.chown(path, uid, gid, function (error) {","missing":[{}]},"324":{"partial":false,"source":"            if (error) {","missing":[{}]},"325":{"partial":false,"source":"                error.message = \"Can't chown (change owner) of \" + JSON.stringify(path) + \" to user \" + JSON.stringify(uid) + \" and group \" + JSON.stringify(gid) + \": \" + error.message;","missing":[{"startCol":32,"endCol":123},{},{"startCol":142,"endCol":161},{"startCol":104,"endCol":123},{"startCol":67,"endCol":87},{"startCol":16,"endCol":185}]},"326":{"partial":false,"source":"                done.reject(error);","missing":[{"startCol":16,"endCol":35},{}]},"327":{"partial":false,"source":"            } else {","missing":[{}]},"328":{"partial":false,"source":"                done.resolve();","missing":[{"startCol":16,"endCol":30},{}]},"329":{"partial":false,"source":"            }","missing":[{}]},"330":{"partial":false,"source":"        });","missing":[{}]},"332":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"334":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"338":{"partial":false,"source":"    path = String(path);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"339":{"partial":false,"source":"    mode = String(mode);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"340":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"342":{"partial":false,"source":"        FS.chmod(path, mode, function (error) {","missing":[{}]},"343":{"partial":false,"source":"            if (error) {","missing":[{}]},"344":{"partial":false,"source":"                error.message = \"Can't chmod (change permissions mode) of \" + JSON.stringify(path) + \" to (octal number) \" + mode.toString(8) + \": \" + error.message;","missing":[{"startCol":16,"endCol":165},{"startCol":32,"endCol":98},{},{"startCol":78,"endCol":98},{"startCol":125,"endCol":141}]},"345":{"partial":false,"source":"                done.reject(error);","missing":[{},{"startCol":16,"endCol":34}]},"346":{"partial":false,"source":"            } else {","missing":[{}]},"347":{"partial":false,"source":"                done.resolve();","missing":[{"startCol":16,"endCol":30},{}]},"348":{"partial":false,"source":"            }","missing":[{}]},"349":{"partial":false,"source":"        });","missing":[{}]},"351":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"353":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"360":{"partial":false,"source":"            error.message = \"Can't get canonical path of \" + JSON.stringify(path) + \" by way of C realpath: \" + error.message;","missing":[{"startCol":12,"endCol":126},{"startCol":28,"endCol":81},{"startCol":61,"endCol":81}]},"361":{"partial":false,"source":"            result.reject(error);","missing":[{"startCol":12,"endCol":32}]},"370":{"partial":false,"source":"    var result = Q.defer();","missing":[{"startCol":4,"endCol":27},{"startCol":17,"endCol":26}]},"371":{"partial":false,"source":"    FS.readlink(path, function (error, path) {","missing":[{}]},"372":{"partial":false,"source":"        if (error) {","missing":[{}]},"373":{"partial":false,"source":"            error.message = \"Can't get link from \" + JSON.stringify(path) + \" by way of C readlink: \" + error.message;","missing":[{"startCol":28,"endCol":117},{"startCol":53,"endCol":73},{},{"startCol":12,"endCol":118}]},"374":{"partial":false,"source":"            result.reject(error);","missing":[{},{"startCol":12,"endCol":32}]},"375":{"partial":false,"source":"        } else {","missing":[{}]},"376":{"partial":false,"source":"            result.resolve(path);","missing":[{},{"startCol":12,"endCol":32}]},"377":{"partial":false,"source":"        }","missing":[{}]},"378":{"partial":false,"source":"    });","missing":[{}]},"379":{"partial":false,"source":"    return result.promise;","missing":[{"startCol":4,"endCol":26}]}},"source":"/**\n * An asynchronous local file system API, based on a subset\n * of the `narwhal/fs` API and the `narwhal/promise` API,\n * such that the method names are the same but some return\n * values are promises instead of fully resolved values.\n * @module\n */\n\n/*whatsupdoc*/\n\nvar FS = require(\"fs\"); // node\nvar Q = require(\"q\");\nvar Reader = require(\"./reader\");\nvar Writer = require(\"./writer\");\nvar Common = require(\"./fs-common\");\nvar Mock = require(\"./fs-mock\");\nvar Root = require(\"./fs-root\");\n\nCommon.update(exports, process.cwd);\nexports.Mock = Mock;\nexports.Root = Root;\n\n// facilitates AIMD (additive increase, multiplicative decrease) for backing off\nvar backOffDelay = 0;\nvar backOffFactor = 1.0001;\nfunction dampen(wrapped, thisp) {\n    var retry = function () {\n        var args = arguments;\n        var ready = backOffDelay ? Q.delay(backOffDelay) : Q.resolve();\n        return ready.then(function () {\n            return Q.when(wrapped.apply(thisp, args), function (stream) {\n                backOffDelay = Math.max(0, backOffDelay - 1);\n                return stream;\n            }, function (error) {\n                if (error.code === \"EMFILE\") {\n                    backOffDelay = (backOffDelay + 1) * backOffFactor;\n                    return retry.apply(null, args);\n                } else {\n                    throw error;\n                }\n            });\n        });\n    };\n    return retry;\n}\n\n/**\n * @param {String} path\n * @param {Object} options (flags, mode, bufferSize, charset, begin, end)\n * @returns {Promise * Stream} a stream from the `q-io` module.\n */\nexports.open = dampen(function (path, flags, charset, options) {\n    var self = this;\n    if (typeof flags == \"object\") {\n        options = flags;\n        flags = options.flags;\n        charset = options.charset;\n    }\n    options = options || {};\n    flags = flags || \"r\";\n    var nodeOptions = {\n        \"flags\": flags.replace(/b/g, \"\")\n    };\n    if (\"bufferSize\" in options) {\n        nodeOptions.bufferSize = options.bufferSize;\n    }\n    if (\"mode\" in options) {\n        nodeOptions.mode = options.mode;\n    }\n    if (\"begin\" in options) {\n        nodeOptions.start = options.begin;\n        nodeOptions.end = options.end - 1;\n    }\n    if (flags.indexOf(\"b\") >= 0) {\n        if (charset) {\n            throw new Error(\"Can't open a binary file with a charset: \" + charset);\n        }\n    } else {\n        charset = charset || 'utf-8';\n    }\n    if (flags.indexOf(\"w\") >= 0) {\n        var stream = FS.createWriteStream(String(path), nodeOptions);\n        return Writer(stream, charset);\n    } else {\n        var stream = FS.createReadStream(String(path), nodeOptions);\n        return Reader(stream, charset);\n    }\n});\n\nexports.remove = function (path) {\n    path = String(path);\n    var done = Q.defer();\n    FS.unlink(path, function (error) {\n        if (error) {\n            error.message = \"Can't remove \" + JSON.stringify(path) + \": \" + error.message;\n            done.reject(error);\n        } else {\n            done.resolve();\n        }\n    });\n    return done.promise;\n};\n\nexports.move = function (source, target) {\n    source = String(source);\n    target = String(target);\n    return exports.exists(target)\n    .then(function (exists) {\n        if (exists) {\n            var error = new Error(\"Can't move over existing entry \" + target);\n            error.code = \"EEXISTS\";\n            throw error;\n        }\n        return Q.ninvoke(FS, \"rename\", source, target)\n        .fail(function (error) {\n            error.message = (\n                \"Can't move \" + JSON.stringify(source) + \" to \" +\n                JSON.stringify(target) + \" because \" + error.message\n            );\n            throw error;\n        });\n    });\n};\n\nexports.makeDirectory = function (path, mode) {\n    path = String(path);\n    var done = Q.defer();\n    if (typeof mode === \"string\") {\n        mode = parseInt(mode, 8);\n    } else if (mode === void 0) {\n        mode = parseInt('755', 8);\n    }\n    FS.mkdir(path, mode, function (error) {\n        if (error) {\n            error.message = \"Can't makeDirectory \" + JSON.stringify(path) + \" with mode \" + mode + \": \" + error.message;\n            if (error.code === \"EISDIR\") {\n                error.exists = true;\n                error.isDirectory = true;\n            }\n            if (error.code === \"EEXIST\") {\n                error.exists = true;\n            }\n            done.reject(error);\n        } else {\n            done.resolve();\n        }\n    });\n    return done.promise;\n};\n\nexports.removeDirectory = function (path) {\n    path = String(path);\n    var done = Q.defer();\n    FS.rmdir(path, function (error) {\n        if (error) {\n            error.message = \"Can't removeDirectory \" + JSON.stringify(path) + \": \" + error.message;\n            done.reject(error);\n        } else {\n            done.resolve();\n        }\n    });\n    return done.promise;\n};\n\n/**\n */\nexports.list = dampen(function (path) {\n    path = String(path);\n    var result = Q.defer();\n    FS.readdir(path, function (error, list) {\n        if (error) {\n            error.message = \"Can't list \" + JSON.stringify(path) + \": \" + error.message;\n            return result.reject(error);\n        } else {\n            result.resolve(list);\n        }\n    });\n    return result.promise;\n});\n\n/**\n * @param {String} path\n * @returns {Promise * Stat}\n */\nexports.stat = function (path) {\n    var self = this;\n    path = String(path);\n    var done = Q.defer();\n    try {\n        FS.stat(path, function (error, stat) {\n            if (error) {\n                error.message = \"Can't stat \" + JSON.stringify(path) + \": \" + error;\n                done.reject(error);\n            } else {\n                done.resolve(new Stats(stat));\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nvar Stats = function (nodeStat) {\n    this.node = nodeStat;\n    this.size = nodeStat.size;\n};\n\nvar stats = [\n    \"isDirectory\",\n    \"isFile\",\n    \"isBlockDevice\",\n    \"isCharacterDevice\",\n    \"isSymbolicLink\",\n    \"isFIFO\",\n    \"isSocket\"\n];\n\nstats.forEach(function (name) {\n    Stats.prototype[name] = function () {\n        return this.node[name]();\n    };\n});\n\nStats.prototype.lastModified = function () {\n    return new Date(this.node.mtime);\n};\n\nStats.prototype.lastAccessed = function () {\n    return new Date(this.node.atime);\n};\n\nexports.statLink = function (path) {\n    path = String(path);\n    var done = Q.defer();\n    try {\n        FS.lstat(path, function (error, stat) {\n            if (error) {\n                error.message = \"Can't statLink \" + JSON.stringify(path) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve(stat);\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.statFd = function (fd) {\n    fd = Number(fd);\n    var done = Q.defer();\n    try {\n        FS.fstat(fd, function (error, stat) {\n            if (error) {\n                error.message = \"Can't statFd file descriptor \" + JSON.stringify(fd) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve(stat);\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.link = function (source, target) {\n    source = String(source);\n    target = String(target);\n    var done = Q.defer();\n    try {\n        FS.link(source, target, function (error) {\n            if (error) {\n                error.message = \"Can't link \" + JSON.stringify(source) + \" to \" + JSON.stringify(target) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\n// this lookup table translates the link types that Q-IO accepts (which have\n// been normalized to full words to be consistent with the naming convention)\nvar linkTypes = {\n    \"file\": \"file\",\n    \"directory\": \"dir\",\n    \"junction\": \"junction\"\n};\n\nexports.symbolicLink = function (target, relative, type) {\n    if (!linkTypes.hasOwnProperty(type)) {\n        console.warn(new Error(\"For Windows compatibility, symbolicLink must be called with a type argument \\\"file\\\", \\\"directory\\\", or \\\"junction\\\"\"));\n    }\n    type = linkTypes[type];\n    target = String(target);\n    relative = String(relative);\n    var done = Q.defer();\n    try {\n        FS.symlink(relative, target, type || 'file', function (error) {\n            if (error) {\n                error.message = \"Can't create symbolicLink \" + JSON.stringify(target) + \" to relative location \" + JSON.stringify(relative) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.chown = function (path, uid, gid) {\n    path = String(path);\n    var done = Q.defer();\n    try {\n        FS.chown(path, uid, gid, function (error) {\n            if (error) {\n                error.message = \"Can't chown (change owner) of \" + JSON.stringify(path) + \" to user \" + JSON.stringify(uid) + \" and group \" + JSON.stringify(gid) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.chmod = function (path, mode) {\n    path = String(path);\n    mode = String(mode);\n    var done = Q.defer();\n    try {\n        FS.chmod(path, mode, function (error) {\n            if (error) {\n                error.message = \"Can't chmod (change permissions mode) of \" + JSON.stringify(path) + \" to (octal number) \" + mode.toString(8) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.canonical = function (path) {\n    var result = Q.defer();\n    FS.realpath(path, function (error, canonicalPath) {\n        if (error) {\n            error.message = \"Can't get canonical path of \" + JSON.stringify(path) + \" by way of C realpath: \" + error.message;\n            result.reject(error);\n        } else {\n            result.resolve(canonicalPath);\n        }\n    });\n    return result.promise;\n};\n\nexports.readLink = function (path) {\n    var result = Q.defer();\n    FS.readlink(path, function (error, path) {\n        if (error) {\n            error.message = \"Can't get link from \" + JSON.stringify(path) + \" by way of C readlink: \" + error.message;\n            result.reject(error);\n        } else {\n            result.resolve(path);\n        }\n    });\n    return result.promise;\n};\n\nexports.mock = function (path) {\n    return Mock.mock(this, path);\n};","blocks":{"total":98,"seen":39,"missing":59,"percentage":0.3979591836734694}},"hash":"fd647282565d132085fea23857f3b9c4"},"/Users/kris/q-io/reader.js":{"stats":{"percentage":0.937984496124031,"lines":[{"lineno":23},{"lineno":37},{"lineno":86},{"lineno":97},{"lineno":98},{"lineno":99},{"lineno":102},{"lineno":104}],"missing":8,"seen":121,"total":129,"coverage":{"23":{"partial":false,"source":"        begin.reject(reason);","missing":[{"startCol":8,"endCol":28}]},"37":{"partial":false,"source":"            receiver(chunk);","missing":[{"startCol":12,"endCol":27}]},"86":{"partial":false,"source":"        _stream.destroy();","missing":[{"startCol":8,"endCol":25}]},"97":{"partial":false,"source":"    var chunks = [];","missing":[{"startCol":4,"endCol":20}]},"98":{"partial":false,"source":"    stream.forEach(function (chunk) {","missing":[{}]},"99":{"partial":false,"source":"        chunks.push(chunk);","missing":[{},{"startCol":8,"endCol":26}]},"100":{"partial":false,"source":"    });","missing":[{}]},"102":{"partial":false,"source":"        return chunks.join(\"\");","missing":[{"startCol":8,"endCol":31},{"startCol":15,"endCol":30}]},"104":{"partial":false,"source":"        return join(chunks);","missing":[{"startCol":8,"endCol":28},{"startCol":15,"endCol":27}]}},"source":"var Q = require(\"q\");\n\n/**\n * Wraps a Node readable stream, providing an API similar\n * to a Narwhal synchronous `io` stream except returning\n * Q promises for long latency operations.\n * @param stream any Node readable stream\n * @returns {Promise * Reader} a promise for\n * the text stream reader.\n * @constructor\n */\nmodule.exports = Reader;\nfunction Reader(_stream, charset) {\n    var self = Object.create(Reader.prototype);\n\n    if (charset && _stream.setEncoding) // TODO complain about inconsistency\n        _stream.setEncoding(charset);\n\n    var begin = Q.defer();\n    var end = Q.defer();\n\n    _stream.on(\"error\", function (reason) {\n        begin.reject(reason);\n    });\n\n    var chunks = [];\n    var receiver;\n\n    _stream.on(\"end\", function () {\n        begin.resolve(self);\n        end.resolve()\n    });\n\n    _stream.on(\"data\", function (chunk) {\n        begin.resolve(self);\n        if (receiver) {\n            receiver(chunk);\n        } else {\n            chunks.push(chunk);\n        }\n    });\n\n    function slurp() {\n        var result;\n        if (charset) {\n            result = chunks.join(\"\");\n        } else {\n            result = self.constructor.join(chunks);\n        }\n        chunks.splice(0, chunks.length);\n        return result;\n    }\n\n    /***\n     * Reads all of the remaining data from the stream.\n     * @returns {Promise * String} a promise for a String\n     * containing the entirety the remaining stream.\n     */\n    self.read = function () {\n        receiver = undefined;\n        var deferred = Q.defer();\n        Q.done(end.promise, function () {\n            deferred.resolve(slurp());\n        });\n        return deferred.promise;\n    };\n\n    /***\n     * Reads and writes all of the remaining data from the\n     * stream in chunks.\n     * @param {Function(Promise * String)} write a function\n     * to be called on each chunk of input from this stream.\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the input is depleted.\n     */\n    self.forEach = function (write) {\n        if (chunks && chunks.length)\n            write(slurp());\n        receiver = write;\n        return Q.when(end.promise, function () {\n            receiver = undefined;\n        });\n    };\n\n    self.close = function () {\n        _stream.destroy();\n    };\n\n    return begin.promise;\n}\n\n/*\n    Reads an entire forEachable stream of buffers and returns a single buffer.\n*/\nReader.read = read;\nfunction read(stream, charset) {\n    var chunks = [];\n    stream.forEach(function (chunk) {\n        chunks.push(chunk);\n    });\n    if (charset) {\n        return chunks.join(\"\");\n    } else {\n        return join(chunks);\n    }\n}\n\nReader.join = join;\nfunction join(buffers) {\n    var length = 0;\n    var at;\n    var i;\n    var ii = buffers.length;\n    var buffer;\n    var result;\n    for (i = 0; i < ii; i++) {\n        buffer = buffers[i];\n        length += buffer.length;\n    }\n    result = new Buffer(length);\n    at = 0;\n    for (i = 0; i < ii; i++) {\n        buffer = buffers[i];\n        buffer.copy(result, at, 0);\n        at += buffer.length;\n    }\n    buffers.splice(0, ii, result);\n    return result;\n}","blocks":{"total":23,"seen":16,"missing":7,"percentage":0.6956521739130435}},"hash":"24c2b103d427c684f91c5cc6d3968af8"},"/Users/kris/q-io/writer.js":{"stats":{"percentage":0.8555555555555555,"lines":[{"lineno":17},{"lineno":23},{"lineno":27},{"lineno":28},{"lineno":29},{"lineno":41},{"lineno":42},{"lineno":43},{"lineno":46},{"lineno":59},{"lineno":84},{"lineno":85},{"lineno":86}],"missing":13,"seen":77,"total":90,"coverage":{"17":{"partial":false,"source":"        _stream.setEncoding(charset);","missing":[{"startCol":8,"endCol":36}]},"23":{"partial":false,"source":"        begin.reject(reason);","missing":[{"startCol":8,"endCol":28}]},"27":{"partial":false,"source":"        begin.resolve(self);","missing":[{"startCol":8,"endCol":27}]},"28":{"partial":false,"source":"        drained.resolve();","missing":[{"startCol":8,"endCol":25}]},"29":{"partial":false,"source":"        drained = Q.defer();","missing":[{"startCol":8,"endCol":28},{"startCol":18,"endCol":27}]},"41":{"partial":false,"source":"            return Q.reject(new Error(\"Can't write to non-writable (possibly closed) stream\"));","missing":[{"startCol":12,"endCol":95},{"startCol":19,"endCol":94}]},"42":{"partial":true,"source":"        if (_stream.encoding == \"binary\" && !(content instanceof Buffer)) {","missing":[{"startCol":45,"endCol":72}]},"43":{"partial":false,"source":"            content = new Buffer(content);","missing":[{"startCol":12,"endCol":42}]},"46":{"partial":false,"source":"            return drained.promise;","missing":[{"startCol":12,"endCol":35}]},"59":{"partial":false,"source":"        return drained.promise;","missing":[{"startCol":8,"endCol":31}]},"84":{"partial":false,"source":"        _stream.destroy();","missing":[{"startCol":8,"endCol":25}]},"85":{"partial":false,"source":"        drained.resolve(); // we will get no further drain events","missing":[{"startCol":8,"endCol":25}]},"86":{"partial":false,"source":"        return Q.resolve(); // destruction not explicitly observable","missing":[{"startCol":8,"endCol":27},{"startCol":15,"endCol":26}]}},"source":"var Q = require(\"q\");\n\n/**\n * Wraps a Node writable stream, providing an API similar to\n * Narwhal's synchronous `io` streams, except returning and\n * accepting promises for long-latency operations.\n *\n * @param stream any Node writable stream\n * @returns {Promise * Writer} a promise for the\n * text writer.\n */\nmodule.exports = Writer;\nfunction Writer(_stream, charset) {\n    var self = Object.create(Writer.prototype);\n\n    if (charset && _stream.setEncoding) // TODO complain about inconsistency\n        _stream.setEncoding(charset);\n\n    var begin = Q.defer();\n    var drained = Q.defer();\n\n    _stream.on(\"error\", function (reason) {\n        begin.reject(reason);\n    });\n\n    _stream.on(\"drain\", function () {\n        begin.resolve(self);\n        drained.resolve();\n        drained = Q.defer();\n    });\n\n    /***\n     * Writes content to the stream.\n     * @param {String} content\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the buffer is empty, meaning\n     * that all of the content has been sent.\n     */\n    self.write = function (content) {\n        if (!_stream.writeable && !_stream.writable)\n            return Q.reject(new Error(\"Can't write to non-writable (possibly closed) stream\"));\n        if (_stream.encoding == \"binary\" && !(content instanceof Buffer)) {\n            content = new Buffer(content);\n        }\n        if (!_stream.write(content)) {\n            return drained.promise;\n        } else {\n            return Q.resolve();\n        }\n    };\n\n    /***\n     * Waits for all data to flush on the stream.\n     *\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the buffer is empty\n     */\n    self.flush = function () {\n        return drained.promise;\n    };\n\n    /***\n     * Closes the stream, waiting for the internal buffer\n     * to flush.\n     *\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the stream has finished writing,\n     * flushing, and closed.\n     */\n    self.close = function () {\n        _stream.end();\n        drained.resolve(); // we will get no further drain events\n        return Q.resolve(); // closing not explicitly observable\n    };\n\n    /***\n     * Terminates writing on a stream, closing before\n     * the internal buffer drains.\n     *\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the stream has finished closing.\n     */\n    self.destroy = function () {\n        _stream.destroy();\n        drained.resolve(); // we will get no further drain events\n        return Q.resolve(); // destruction not explicitly observable\n    };\n\n    return Q.resolve(self); // todo returns the begin.promise\n}","blocks":{"total":12,"seen":4,"missing":8,"percentage":0.3333333333333333}},"hash":"9b9069a93531cd756b09d565776ec317"},"/Users/kris/q-io/fs-common.js":{"stats":{"percentage":0.9059633027522935,"lines":[{"lineno":41},{"lineno":42},{"lineno":43},{"lineno":44},{"lineno":45},{"lineno":70},{"lineno":71},{"lineno":74},{"lineno":97},{"lineno":105},{"lineno":148},{"lineno":151},{"lineno":171},{"lineno":190},{"lineno":195},{"lineno":196},{"lineno":219},{"lineno":230},{"lineno":267},{"lineno":288},{"lineno":289},{"lineno":293},{"lineno":294},{"lineno":307},{"lineno":330},{"lineno":331},{"lineno":338},{"lineno":339},{"lineno":368},{"lineno":369},{"lineno":371},{"lineno":381},{"lineno":382},{"lineno":383},{"lineno":384},{"lineno":385},{"lineno":386},{"lineno":387},{"lineno":388},{"lineno":389},{"lineno":391}],"missing":41,"seen":395,"total":436,"coverage":{"41":{"partial":false,"source":"            error.message = \"Can't read \" + path + \" because \" + error.message;","missing":[{"startCol":12,"endCol":79},{"startCol":28,"endCol":48}]},"42":{"partial":false,"source":"            error.path = path;","missing":[{"startCol":12,"endCol":30}]},"43":{"partial":false,"source":"            error.flags = flags;","missing":[{"startCol":12,"endCol":32}]},"44":{"partial":false,"source":"            error.charset = charset;","missing":[{"startCol":12,"endCol":36}]},"45":{"partial":false,"source":"            throw error;","missing":[{"startCol":12,"endCol":24}]},"70":{"partial":false,"source":"            if (!(content instanceof Buffer)) {","missing":[{"startCol":17,"endCol":44}]},"71":{"partial":false,"source":"                content = new Buffer(content);","missing":[{"startCol":16,"endCol":46}]},"74":{"partial":false,"source":"            flags += \"b\";","missing":[{"startCol":12,"endCol":25}]},"97":{"partial":false,"source":"            options = flags;","missing":[{"startCol":12,"endCol":28}]},"105":{"partial":false,"source":"            flags += \"b\";","missing":[{"startCol":12,"endCol":25}]},"148":{"partial":false,"source":"            } else if (stat.isSymbolicLink()) {","missing":[{"startCol":23,"endCol":44}]},"151":{"partial":false,"source":"                return self.symbolicCopy(source, target);","missing":[{"startCol":16,"endCol":57},{"startCol":23,"endCol":56}]},"171":{"partial":false,"source":"                return Q.reject(exception);","missing":[{"startCol":16,"endCol":43},{"startCol":23,"endCol":42}]},"190":{"partial":false,"source":"            return [];","missing":[{"startCol":12,"endCol":22}]},"195":{"partial":false,"source":"        return this.listTree(path, function (path, stat) {","missing":[{}]},"196":{"partial":false,"source":"            return stat.isDirectory();","missing":[{"startCol":19,"endCol":37},{},{"startCol":12,"endCol":38}]},"197":{"partial":false,"source":"        });","missing":[{}]},"219":{"partial":false,"source":"                        throw error;","missing":[{"startCol":24,"endCol":36}]},"230":{"partial":false,"source":"                return self.remove(path);","missing":[{"startCol":16,"endCol":41},{"startCol":23,"endCol":40}]},"267":{"partial":false,"source":"            return false;","missing":[{"startCol":12,"endCol":25}]},"288":{"partial":false,"source":"        var self = this;","missing":[{"startCol":8,"endCol":24}]},"289":{"partial":false,"source":"        return self.stat(path).invoke('lastModified');","missing":[{"startCol":8,"endCol":54},{"startCol":15,"endCol":53},{"startCol":24,"endCol":30}]},"293":{"partial":false,"source":"        var self = this;","missing":[{"startCol":8,"endCol":24}]},"294":{"partial":false,"source":"        return self.stat(path).invoke('lastAccessed');","missing":[{"startCol":8,"endCol":54},{"startCol":15,"endCol":53},{"startCol":24,"endCol":30}]},"307":{"partial":false,"source":"                return self.relativeFromDirectory(source, target);","missing":[{"startCol":16,"endCol":66},{"startCol":23,"endCol":65}]},"330":{"partial":false,"source":"            source.shift();","missing":[{"startCol":12,"endCol":26}]},"331":{"partial":false,"source":"            target.unshift(\"..\");","missing":[{"startCol":12,"endCol":32}]},"338":{"partial":false,"source":"            target = source;","missing":[{"startCol":12,"endCol":28}]},"339":{"partial":false,"source":"            source = workingDirectory();","missing":[{"startCol":12,"endCol":40},{"startCol":21,"endCol":39}]},"368":{"partial":true,"source":"        if (parent.length === 2 && parent[1] === \"\")","missing":[{"startCol":35,"endCol":51}]},"369":{"partial":false,"source":"            parent.pop();","missing":[{"startCol":12,"endCol":24}]},"371":{"partial":false,"source":"            return false;","missing":[{"startCol":12,"endCol":25}]},"381":{"partial":false,"source":"        var self = this;","missing":[{"startCol":8,"endCol":24}]},"382":{"partial":false,"source":"        path = path || this.ROOT;","missing":[{"startCol":8,"endCol":33},{"startCol":15,"endCol":32}]},"383":{"partial":false,"source":"        return Q.when(this.list(path), function (list) {","missing":[{},{"startCol":22,"endCol":37}]},"384":{"partial":false,"source":"            if (list.length !== 1)","missing":[{},{"startCol":16,"endCol":33}]},"385":{"partial":false,"source":"                return RootFs(self, path);","missing":[{},{"startCol":16,"endCol":42},{"startCol":23,"endCol":41}]},"386":{"partial":false,"source":"            var nextPath = self.join(path, list[0]);","missing":[{"startCol":27,"endCol":51},{},{"startCol":12,"endCol":52}]},"387":{"partial":false,"source":"            return Q.when(self.stat(nextPath), function (stat) {","missing":[{},{"startCol":26,"endCol":45}]},"388":{"partial":false,"source":"                if (stat.isDirectory()) {","missing":[{},{"startCol":20,"endCol":38}]},"389":{"partial":false,"source":"                    return reroot(nextPath);","missing":[{"startCol":27,"endCol":43},{},{"startCol":20,"endCol":44}]},"390":{"partial":false,"source":"                } else {","missing":[{}]},"391":{"partial":false,"source":"                    return RootFs(self, path);","missing":[{"startCol":20,"endCol":46},{},{"startCol":27,"endCol":45}]},"392":{"partial":false,"source":"                }","missing":[{}]},"393":{"partial":false,"source":"            });","missing":[{}]},"394":{"partial":false,"source":"        });","missing":[{}]}},"source":"var Q = require(\"q\");\nvar Boot = require(\"./fs-boot\");\nvar RootFs = require(\"./fs-root\");\nvar MockFs = require(\"./fs-mock\");\n\n// TODO patternToRegExp\n// TODO glob\n// TODO match\n\nvar concat = function (arrays) {\n    return Array.prototype.concat.apply([], arrays);\n};\n\nexports.update = function (exports, workingDirectory) {\n\n    for (var name in Boot) {\n        exports[name] = Boot[name];\n    }\n\n    /**\n     * Read a complete file.\n     * @param {String} path    Path to the file.\n     * @param {Object} [options]   An object with options.\n     * @param {String} [options.flags]  The mode to open the file with.\n     * @param {String} [options.charset]  The charset to open the file with.\n     * second argument.\n     * @returns {Promise * (String || Buffer)}\n     */\n    exports.read = function (path, flags, charset, options) {\n        if (typeof flags == \"object\") {\n            options = flags;\n        } else {\n            options = options || {};\n            options.flags = flags;\n            options.charset = charset;\n        }\n        options.flags = \"r\" + (options.flags || \"\").replace(/r/g, \"\");\n        return Q.when(this.open(path, options), function (stream) {\n            return stream.read();\n        }, function (error) {\n            error.message = \"Can't read \" + path + \" because \" + error.message;\n            error.path = path;\n            error.flags = flags;\n            error.charset = charset;\n            throw error;\n        });\n    };\n\n    /**\n     * Write content to a file, overwriting the existing content.\n     * @param {String} path    Path to the file.\n     * @param {String || Buffer} content\n     * @param {Object} [options]   An object with options.\n     * @param {String} [options.flags]  The mode to open the file with.\n     * @param {String} [options.charset]  The charset to open the file with.\n     * @returns {Promise * Undefined} a promise that resolves\n     * when the writing is complete.\n     */\n    exports.write = function (path, content, flags, charset, options) {\n        var self = this;\n        if (typeof flags == \"object\") {\n            options = flags;\n        } else {\n            options = options || {};\n            options.flags = flags;\n            options.charset = charset;\n        }\n        flags = \"w\" + (options.flags || \"\").replace(/[w]/g, \"\");\n        if (flags.indexOf(\"b\") !== -1) {\n            if (!(content instanceof Buffer)) {\n                content = new Buffer(content);\n            }\n        } else if (content instanceof Buffer) {\n            flags += \"b\";\n        }\n        options.flags = flags;\n        return Q.when(self.open(path, options), function (stream) {\n            return Q.when(stream.write(content), function () {\n                return stream.close();\n            });\n        });\n    };\n\n    /**\n     * Append content to the end of a file.\n     * @param {String} path    Path to the file.\n     * @param {String || Buffer} content\n     * @param {Object} [options]   An object with options.\n     * @param {String} [options.flags]  The mode to open the file with.\n     * @param {String} [options.charset]  The charset to open the file with.\n     * @returns {Promise * Undefined} a promise that resolves\n     * when the writing is complete.\n     */\n    exports.append = function (path, content, flags, charset, options) {\n        var self = this;\n        if (typeof flags == \"object\") {\n            options = flags;\n        } else {\n            options = options || {};\n            options.flags = flags;\n            options.charset = charset;\n        }\n        flags = \"w+\" + (options.flags || \"\").replace(/[w\\+]/g, \"\");\n        if (content instanceof Buffer) {\n            flags += \"b\";\n        }\n        options.flags = flags;\n        return Q.when(self.open(path, options), function (stream) {\n            return Q.when(stream.write(content), function () {\n                return stream.close();\n            });\n        });\n    };\n\n    exports.copy = function (source, target) {\n        var self = this;\n        return Q.spread([\n            self.open(source, {flags: \"rb\"}),\n            self.open(target, {flags: \"wb\"})\n        ], function (reader, writer) {\n            return Q.when(reader.forEach(function (block) {\n                return writer.write(block);\n            }), function () {\n                return Q.all([\n                    reader.close(),\n                    writer.close()\n                ]);\n            });\n        });\n    };\n\n    exports.copyTree = function (source, target) {\n        var self = this;\n        return Q.when(self.stat(source), function (stat) {\n            if (stat.isFile()) {\n                return self.copy(source, target);\n            } else if (stat.isDirectory()) {\n                return Q.when(self.makeDirectory(target), function () {\n                    return Q.when(self.list(source), function (list) {\n                        return Q.all(list.map(function (child) {\n                            return self.copyTree(\n                                self.join(source, child),\n                                self.join(target, child)\n                            );\n                        }));\n                    });\n                });\n            } else if (stat.isSymbolicLink()) {\n                // TODO copy the link and type with readPath (but what about\n                // Windows junction type?)\n                return self.symbolicCopy(source, target);\n            }\n        });\n    };\n\n    exports.listTree = function (basePath, guard) {\n        var self = this;\n        basePath = String(basePath || '');\n        if (!basePath)\n            basePath = \".\";\n        guard = guard || function () {\n            return true;\n        };\n        var stat = self.stat(basePath);\n        return Q.when(stat, function (stat) {\n            var paths = [];\n            var mode; // true:include, false:exclude, null:no-recur\n            try {\n                var include = guard(basePath, stat);\n            } catch (exception) {\n                return Q.reject(exception);\n            }\n            return Q.when(include, function (include) {\n                if (include) {\n                    paths.push([basePath]);\n                }\n                if (include !== null && stat.isDirectory()) {\n                    return Q.when(self.list(basePath), function (children) {\n                        paths.push.apply(paths, children.map(function (child) {\n                            var path = self.join(basePath, child);\n                            return self.listTree(path, guard);\n                        }));\n                        return paths;\n                    });\n                } else {\n                    return paths;\n                }\n            });\n        }, function noSuchFile(reason) {\n            return [];\n        }).then(Q.all).then(concat);\n    };\n\n    exports.listDirectoryTree = function (path) {\n        return this.listTree(path, function (path, stat) {\n            return stat.isDirectory();\n        });\n    };\n\n    exports.makeTree = function (path, mode) {\n        var self = this;\n        var parts = self.split(path);\n        var at = [];\n        if (self.isAbsolute(path)) {\n            // On Windows use the root drive (e.g. \"C:\"), on *nix the first\n            // part is the falsey \"\", and so use the ROOT (\"/\")\n            at.push(parts.shift() || self.ROOT);\n        }\n        return parts.reduce(function (parent, part) {\n            return Q.when(parent, function () {\n                at.push(part);\n                var parts = self.join(at);\n                var made = self.makeDirectory(parts, mode);\n                return Q.when(made, null, function rejected(error) {\n                    // throw away errors for already made directories\n                    if (error.exists) {\n                        return;\n                    } else {\n                        throw error;\n                    }\n                });\n            });\n        }, undefined);\n    };\n\n    exports.removeTree = function (path) {\n        var self = this;\n        return Q.when(self.stat(path), function (stat) {\n            if (stat.isSymbolicLink()) {\n                return self.remove(path);\n            } else if (stat.isDirectory()) {\n                return self.list(path)\n                .then(function (list) {\n                    // asynchronously remove every subtree\n                    return Q.all(list.map(function (name) {\n                        return self.removeTree(self.join(path, name));\n                    }))\n                    .then(function () {\n                        return self.removeDirectory(path);\n                    });\n                });\n            } else {\n                return self.remove(path);\n            }\n        });\n    };\n\n    exports.symbolicCopy = function (source, target, type) {\n        var self = this;\n        return Q.when(self.relative(target, source), function (relative) {\n            return self.symbolicLink(target, relative, type || \"file\");\n        });\n    };\n\n    exports.exists = function (path) {\n        return Q.when(this.stat(path), function () {\n            return true;\n        }, function () {\n            return false;\n        });\n    };\n\n    exports.isFile = function (path) {\n        return Q.when(this.stat(path), function (stat) {\n            return stat.isFile();\n        }, function (reason) {\n            return false;\n        });\n    };\n\n    exports.isDirectory = function (path) {\n        return Q.when(this.stat(path), function (stat) {\n            return stat.isDirectory();\n        }, function (reason) {\n            return false;\n        });\n    };\n\n    exports.isSymbolicLink = function (path) {\n        return Q.when(this.statLink(path), function (stat) {\n            return stat.isSymbolicLink();\n        }, function (reason) {\n            return false;\n        });\n    };\n\n    exports.lastModified = function (path) {\n        var self = this;\n        return self.stat(path).invoke('lastModified');\n    };\n\n    exports.lastAccessed = function (path) {\n        var self = this;\n        return self.stat(path).invoke('lastAccessed');\n    };\n\n    exports.absolute = function (path) {\n        if (this.isAbsolute(path))\n            return this.normal(path);\n        return this.join(workingDirectory(), path);\n    };\n\n    exports.relative = function (source, target) {\n        var self = this;\n        return Q.when(this.isDirectory(source), function (isDirectory) {\n            if (isDirectory) {\n                return self.relativeFromDirectory(source, target);\n            } else {\n                return self.relativeFromFile(source, target);\n            }\n        });\n    };\n\n    exports.relativeFromFile = function (source, target) {\n        var self = this;\n        source = self.absolute(source);\n        target = self.absolute(target);\n        source = source.split(self.SEPARATORS_RE());\n        target = target.split(self.SEPARATORS_RE());\n        source.pop();\n        while (\n            source.length &&\n            target.length &&\n            target[0] == source[0]\n        ) {\n            source.shift();\n            target.shift();\n        }\n        while (source.length) {\n            source.shift();\n            target.unshift(\"..\");\n        }\n        return target.join(self.SEPARATOR);\n    };\n\n    exports.relativeFromDirectory = function (source, target) {\n        if (!target) {\n            target = source;\n            source = workingDirectory();\n        }\n        source = this.absolute(source);\n        target = this.absolute(target);\n        source = source.split(this.SEPARATORS_RE());\n        target = target.split(this.SEPARATORS_RE());\n        if (source.length === 2 && source[1] === \"\")\n            source.pop();\n        while (\n            source.length &&\n            target.length &&\n            target[0] == source[0]\n        ) {\n            source.shift();\n            target.shift();\n        }\n        while (source.length) {\n            source.shift();\n            target.unshift(\"..\");\n        }\n        return target.join(this.SEPARATOR);\n    };\n\n    exports.contains = function (parent, child) {\n        var i, ii;\n        parent = this.absolute(parent);\n        child = this.absolute(child);\n        parent = parent.split(this.SEPARATORS_RE());\n        child = child.split(this.SEPARATORS_RE());\n        if (parent.length === 2 && parent[1] === \"\")\n            parent.pop();\n        if (parent.length > child.length)\n            return false;\n        for (i = 0, ii = parent.length; i < ii; i++) {\n            if (parent[i] !== child[i])\n                break;\n        }\n        return i == ii;\n    };\n\n    exports.reroot = reroot;\n    function reroot(path) {\n        var self = this;\n        path = path || this.ROOT;\n        return Q.when(this.list(path), function (list) {\n            if (list.length !== 1)\n                return RootFs(self, path);\n            var nextPath = self.join(path, list[0]);\n            return Q.when(self.stat(nextPath), function (stat) {\n                if (stat.isDirectory()) {\n                    return reroot(nextPath);\n                } else {\n                    return RootFs(self, path);\n                }\n            });\n        });\n    }\n\n    exports.toObject = function (path) {\n        var self = this;\n        var list = self.listTree(path || \"\", function (path, stat) {\n            return stat.isFile();\n        });\n        return Q.when(list, function (list) {\n            var tree = {};\n            return Q.all(list.map(function (path) {\n                return Q.when(self.read(path, \"rb\"), function (content) {\n                    tree[path] = content;\n                });\n            })).then(function () {\n                return tree;\n            });\n        });\n    };\n\n    exports.merge = function (fss) {\n        var tree = {};\n        var done;\n        fss.forEach(function (fs) {\n            done = Q.when(done, function () {\n                return fs.listTree(\"\", function (path, stat) {\n                    return stat.isFile();\n                })\n                .then(function (list) {\n                    return Q.all(list.map(function (path) {\n                        return Q.when(fs.read(path, \"rb\"), function (content) {\n                            tree[path] = content;\n                        });\n                    }));\n                });\n            });\n        })\n        return Q.when(done, function () {\n            return MockFs(tree);\n        });\n    };\n\n}","blocks":{"total":119,"seen":91,"missing":28,"percentage":0.7647058823529411}},"hash":"de65bf44e1191ebe500c5262d22f9b3a"},"/Users/kris/q-io/fs-root.js":{"stats":{"percentage":0.8791208791208791,"lines":[{"lineno":18},{"lineno":44},{"lineno":50},{"lineno":59},{"lineno":64},{"lineno":65},{"lineno":67},{"lineno":75},{"lineno":80},{"lineno":81},{"lineno":83}],"missing":11,"seen":80,"total":91,"coverage":{"18":{"partial":false,"source":"            actual = outer.relativeFromDirectory(outer.ROOT, path);","missing":[{"startCol":12,"endCol":67},{"startCol":21,"endCol":66}]},"44":{"partial":false,"source":"                return Q.reject(\"Can't find: \" + JSON.stringify(path));","missing":[{"startCol":16,"endCol":71},{"startCol":23,"endCol":70},{"startCol":32,"endCol":69},{"startCol":49,"endCol":69}]},"50":{"partial":false,"source":"        return outer.ROOT;","missing":[{"startCol":8,"endCol":26}]},"59":{"partial":false,"source":"            return Q.reject(\"Can't list \" + JSON.stringify(path));","missing":[{"startCol":12,"endCol":66},{"startCol":19,"endCol":65},{"startCol":28,"endCol":64},{"startCol":44,"endCol":64}]},"64":{"partial":false,"source":"        return Q.when(attenuate(path), function (path) {","missing":[{},{"startCol":22,"endCol":37}]},"65":{"partial":false,"source":"            return outer.open(path.outer, flags, charset);","missing":[{},{"startCol":19,"endCol":57},{"startCol":12,"endCol":58}]},"66":{"partial":false,"source":"        }).then(null, function (reason) {","missing":[{}]},"67":{"partial":false,"source":"            return Q.reject(\"Can't open \" + JSON.stringify(path));","missing":[{},{"startCol":12,"endCol":66},{"startCol":44,"endCol":64},{"startCol":28,"endCol":64},{"startCol":19,"endCol":65}]},"68":{"partial":false,"source":"        });","missing":[{}]},"75":{"partial":false,"source":"            return Q.reject(\"Can't stat \" + JSON.stringify(path));","missing":[{"startCol":12,"endCol":66},{"startCol":19,"endCol":65},{"startCol":28,"endCol":64},{"startCol":44,"endCol":64}]},"80":{"partial":false,"source":"        return Q.when(attenuate(path), function (path) {","missing":[{"startCol":22,"endCol":37},{}]},"81":{"partial":false,"source":"            return path.inner;","missing":[{},{"startCol":12,"endCol":30}]},"82":{"partial":false,"source":"        }).then(null, function (reason) {","missing":[{}]},"83":{"partial":false,"source":"            return Q.reject(\"Can't find canonical of \" + JSON.stringify(path));","missing":[{},{"startCol":57,"endCol":77},{"startCol":12,"endCol":79},{"startCol":19,"endCol":78},{"startCol":28,"endCol":77}]},"84":{"partial":false,"source":"        });","missing":[{}]}},"source":"var Q = require(\"q\");\nvar BOOT = require(\"./fs-boot\");\nvar COMMON = require(\"./fs-common\");\n\nmodule.exports = RootFs;\n\nfunction RootFs(outer, root) {\n    var inner = Object.create(BOOT);\n\n    function attenuate(path) {\n\n        // the machinations of projecting a path inside a\n        // subroot\n        var actual;\n        // if it's absolute, we want the path relative to\n        // the root of the inner file system\n        if (outer.isAbsolute(path)) {\n            actual = outer.relativeFromDirectory(outer.ROOT, path);\n        } else {\n            actual = path;\n        }\n        // we join the path onto the root of the inner file\n        // system so that parent references from the root\n        // return to the root, emulating standard unix\n        // behavior\n        actual = outer.join(outer.ROOT, actual);\n        // then we reconstruct the path relative to the\n        // inner root\n        actual = outer.relativeFromDirectory(outer.ROOT, actual);\n        // and rejoin it on the outer root\n        actual = outer.join(root, actual);\n        // and find the corresponding real path\n        actual = outer.canonical(actual);\n        return Q.when(actual, function (actual) {\n            // and verify that the outer canonical path is\n            // actually inside the inner canonical path, to\n            // prevent break-outs\n            if (outer.contains(root, actual)) {\n                return {\n                    \"inner\": outer.join(outer.ROOT, outer.relativeFromDirectory(root, actual)),\n                    \"outer\": actual\n                };\n            } else {\n                return Q.reject(\"Can't find: \" + JSON.stringify(path));\n            }\n        });\n    }\n\n    function workingDirectory() {\n        return outer.ROOT;\n    }\n\n    COMMON.update(inner, workingDirectory);\n\n    inner.list = function (path) {\n        return Q.when(attenuate(path), function (path) {\n            return outer.list(path.outer);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't list \" + JSON.stringify(path));\n        });\n    };\n\n    inner.open = function (path, flags, charset) {\n        return Q.when(attenuate(path), function (path) {\n            return outer.open(path.outer, flags, charset);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't open \" + JSON.stringify(path));\n        });\n    };\n\n    inner.stat = function (path) {\n        return Q.when(attenuate(path), function (path) {\n            return outer.stat(path.outer);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't stat \" + JSON.stringify(path));\n        });\n    };\n\n    inner.canonical = function (path) {\n        return Q.when(attenuate(path), function (path) {\n            return path.inner;\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't find canonical of \" + JSON.stringify(path));\n        });\n    };\n\n    return Q.when(outer.canonical(root), function (_root) {\n        root = _root;\n        return inner;\n    });\n}","blocks":{"total":21,"seen":10,"missing":11,"percentage":0.47619047619047616}},"hash":"0f5b78a15cb9d4d170bc48f1df919a3a"},"/Users/kris/q-io/fs-mock.js":{"stats":{"percentage":0.8998109640831758,"lines":[{"lineno":63},{"lineno":77},{"lineno":84},{"lineno":98},{"lineno":105},{"lineno":109},{"lineno":135},{"lineno":138},{"lineno":141},{"lineno":155},{"lineno":156},{"lineno":157},{"lineno":158},{"lineno":179},{"lineno":182},{"lineno":185},{"lineno":205},{"lineno":218},{"lineno":224},{"lineno":226},{"lineno":227},{"lineno":240},{"lineno":241},{"lineno":248},{"lineno":249},{"lineno":250},{"lineno":251},{"lineno":256},{"lineno":257},{"lineno":258},{"lineno":259},{"lineno":275},{"lineno":276},{"lineno":277},{"lineno":284},{"lineno":285},{"lineno":286},{"lineno":320},{"lineno":356},{"lineno":377},{"lineno":378},{"lineno":379},{"lineno":381},{"lineno":388},{"lineno":400},{"lineno":408},{"lineno":428},{"lineno":432},{"lineno":483},{"lineno":489},{"lineno":511},{"lineno":512},{"lineno":513}],"missing":53,"seen":476,"total":529,"coverage":{"63":{"partial":false,"source":"            new Error(\"Can't list non-directory: \" + JSON.stringify(path));","missing":[{"startCol":12,"endCol":75},{"startCol":22,"endCol":73},{"startCol":53,"endCol":73}]},"77":{"partial":false,"source":"            throw new Error(\"Can't find \" + path + \" because \" + directory + \" is not a directory\");","missing":[{"startCol":12,"endCol":100},{"startCol":28,"endCol":48}]},"84":{"partial":false,"source":"            options = options || {};","missing":[{"startCol":12,"endCol":36},{"startCol":22,"endCol":35}]},"98":{"partial":false,"source":"                throw new Error(\"Can't write non-file \" + path);","missing":[{"startCol":16,"endCol":64},{"startCol":32,"endCol":62}]},"105":{"partial":false,"source":"                throw new Error(\"Can't read non-existant \" + path);","missing":[{"startCol":16,"endCol":67},{"startCol":32,"endCol":65}]},"109":{"partial":false,"source":"                throw new Error(\"Can't read non-file \" + path);","missing":[{"startCol":16,"endCol":63},{"startCol":32,"endCol":61}]},"135":{"partial":false,"source":"            throw new Error(\"Can't remove file from non-directory: \" + path);","missing":[{"startCol":12,"endCol":77},{"startCol":28,"endCol":75}]},"138":{"partial":false,"source":"            throw new Error(\"Can't remove non-existant file: \" + path);","missing":[{"startCol":12,"endCol":71},{"startCol":28,"endCol":69}]},"141":{"partial":false,"source":"            throw new Error(\"Can't remove directory. Use removeDirectory: \" + path);","missing":[{"startCol":12,"endCol":84},{"startCol":28,"endCol":82}]},"155":{"partial":false,"source":"            var error =  new Error(\"Can't make directory in non-directory: \" + path);","missing":[{"startCol":12,"endCol":85},{"startCol":35,"endCol":83}]},"156":{"partial":false,"source":"            error.code = \"EEXISTS\";","missing":[{"startCol":12,"endCol":35}]},"157":{"partial":false,"source":"            error.exists = true;","missing":[{"startCol":12,"endCol":32}]},"158":{"partial":false,"source":"            throw error;","missing":[{"startCol":12,"endCol":24}]},"179":{"partial":false,"source":"            throw new Error(\"Can't remove directory from non-directory: \" + path);","missing":[{"startCol":12,"endCol":82},{"startCol":28,"endCol":80}]},"182":{"partial":false,"source":"            throw new Error(\"Can't remove non-existant directory: \" + path);","missing":[{"startCol":12,"endCol":76},{"startCol":28,"endCol":74}]},"185":{"partial":false,"source":"            throw new Error(\"Can't remove non-directory: \" + path);","missing":[{"startCol":12,"endCol":67},{"startCol":28,"endCol":65}]},"205":{"partial":false,"source":"            throw new Error(\"Path is not symbolic link: \" + JSON.stringify(path));","missing":[{"startCol":12,"endCol":82},{"startCol":28,"endCol":80},{"startCol":60,"endCol":80}]},"218":{"partial":false,"source":"            throw new Error(\"Can't link non-file: \" + source);","missing":[{"startCol":12,"endCol":62},{"startCol":28,"endCol":60}]},"224":{"partial":false,"source":"            throw new Error(\"Can't create link in non-directory: \" + target);","missing":[{"startCol":12,"endCol":77},{"startCol":28,"endCol":75}]},"226":{"partial":true,"source":"        if (targetNode._entries[base] && targetNode._entries[base].isDirectory()) {","missing":[{"startCol":41,"endCol":80}]},"227":{"partial":false,"source":"            throw new Error(\"Can't overwrite existing directory with hard link: \" + target);","missing":[{"startCol":12,"endCol":92},{"startCol":28,"endCol":90}]},"240":{"partial":true,"source":"        if (node._entries[base] && node._entries[base].isDirectory()) {","missing":[{"startCol":35,"endCol":68}]},"241":{"partial":false,"source":"            throw new Error(\"Can't overwrite existing directory with symbolic link: \" + target);","missing":[{"startCol":12,"endCol":96},{"startCol":28,"endCol":94}]},"248":{"partial":false,"source":"    var self = this;","missing":[{"startCol":4,"endCol":20}]},"249":{"partial":false,"source":"    return Q.fcall(function () {","missing":[{}]},"250":{"partial":false,"source":"        path = self.absolute(path);","missing":[{},{"startCol":8,"endCol":35},{"startCol":15,"endCol":34}]},"251":{"partial":false,"source":"        self._root._walk(path)._follow(path)._owner = owner;","missing":[{"startCol":38,"endCol":44},{},{"startCol":8,"endCol":60},{"startCol":24,"endCol":30}]},"252":{"partial":false,"source":"    });","missing":[{}]},"256":{"partial":false,"source":"    var self = this;","missing":[{"startCol":4,"endCol":20}]},"257":{"partial":false,"source":"    return Q.fcall(function () {","missing":[{}]},"258":{"partial":false,"source":"        path = self.absolute(path);","missing":[{},{"startCol":8,"endCol":35},{"startCol":15,"endCol":34}]},"259":{"partial":false,"source":"        self._root._walk(path)._follow(path)._mode = mode;","missing":[{"startCol":8,"endCol":58},{"startCol":24,"endCol":30},{},{"startCol":38,"endCol":44}]},"260":{"partial":false,"source":"    });","missing":[{}]},"275":{"partial":false,"source":"            var error = new Error(\"Can't copy non-existent file: \" + source);","missing":[{"startCol":12,"endCol":77},{"startCol":34,"endCol":75}]},"276":{"partial":false,"source":"            error.code = \"ENOENT\";","missing":[{"startCol":12,"endCol":34}]},"277":{"partial":false,"source":"            throw error;","missing":[{"startCol":12,"endCol":24}]},"284":{"partial":false,"source":"            var error = new Error(\"Can't copy non-existent file: \" + source);","missing":[{"startCol":12,"endCol":77},{"startCol":34,"endCol":75}]},"285":{"partial":false,"source":"            error.code = \"ENOENT\";","missing":[{"startCol":12,"endCol":34}]},"286":{"partial":false,"source":"            throw error;","missing":[{"startCol":12,"endCol":24}]},"320":{"partial":false,"source":"            throw new Error(\"Can't read non-symbolic link: \" + path);","missing":[{"startCol":12,"endCol":69},{"startCol":28,"endCol":67}]},"356":{"partial":false,"source":"        throw new Error(\"FS required argument\");","missing":[{"startCol":8,"endCol":48}]},"377":{"partial":false,"source":"        var part = parts.shift();","missing":[{"startCol":8,"endCol":33},{"startCol":19,"endCol":32}]},"378":{"partial":false,"source":"        if (part === \"\") {","missing":[{"startCol":12,"endCol":23}]},"379":{"partial":false,"source":"            return this._walkParts(parts, make, this._fs.join(via, part));","missing":[{"startCol":12,"endCol":74},{"startCol":19,"endCol":73},{"startCol":48,"endCol":72}]},"381":{"partial":false,"source":"            throw new Error(\"Can't find \" + JSON.stringify(this._fs.resolve(part, this._fs.join(parts))) + \" via \" + JSON.stringify(via));","missing":[{"startCol":12,"endCol":138},{"startCol":28,"endCol":104},{"startCol":44,"endCol":104},{"startCol":59,"endCol":103},{"startCol":82,"endCol":102},{"startCol":117,"endCol":136}]},"388":{"partial":false,"source":"        throw new Error(\"Path must be absolute for _canonical: \" + path);","missing":[{"startCol":8,"endCol":73},{"startCol":24,"endCol":71}]},"400":{"partial":false,"source":"    return this._fs.join(via, this._fs.join(parts));","missing":[{"startCol":4,"endCol":52},{"startCol":11,"endCol":51},{"startCol":30,"endCol":50}]},"408":{"partial":false,"source":"    this._modified = new Date();","missing":[{"startCol":4,"endCol":32}]},"428":{"partial":false,"source":"    return this._accessed;","missing":[{"startCol":4,"endCol":26}]},"432":{"partial":false,"source":"    return this._modified;","missing":[{"startCol":4,"endCol":26}]},"483":{"partial":false,"source":"        return via;","missing":[{"startCol":8,"endCol":19}]},"489":{"partial":false,"source":"        return this._fs.join(via, part, this._fs.join(parts));","missing":[{"startCol":8,"endCol":62},{"startCol":15,"endCol":61},{"startCol":40,"endCol":60}]},"511":{"partial":false,"source":"        var error = new Error(\"Can't follow symbolic link cycle at \" + JSON.stringify(via));","missing":[{"startCol":8,"endCol":92},{"startCol":30,"endCol":90},{"startCol":71,"endCol":90}]},"512":{"partial":false,"source":"        error.code = \"ELOOP\";","missing":[{"startCol":8,"endCol":29}]},"513":{"partial":false,"source":"        throw error;","missing":[{"startCol":8,"endCol":20}]}},"source":"var Q = require(\"q\");\nvar Boot = require(\"./fs-boot\");\nvar Common = require(\"./fs-common\");\nvar BufferStream = require(\"./buffer-stream\");\nvar Reader = require(\"./reader\");\nvar Set = require(\"collections/set\");\n\nmodule.exports = MockFs;\n\nfunction MockFs(files, workingDirectory) {\n    if (!(this instanceof MockFs)) {\n        return new MockFs(files, workingDirectory);\n    }\n    this._root = new DirectoryNode(this, \"/\");\n\n    function init() {\n        // construct a file tree\n    }\n\n    Common.update(this, function () {\n        return workingDirectory;\n    });\n\n    workingDirectory = workingDirectory || this.ROOT;\n    if (files) {\n        this._init(files);\n    }\n}\n\nMockFs.prototype = Object.create(Boot);\n\nMockFs.prototype._init = function (files, tree) {\n    tree = tree || this.ROOT;\n    Object.keys(files).forEach(function (path) {\n        var content = files[path];\n        path = this.join(tree, path);\n        var directory = this.directory(path);\n        var base = this.base(path);\n        var directoryNode = this._root._walk(directory, true);\n        var fileNode = new FileNode(this);\n        if (!(content instanceof Buffer)) {\n            if (typeof content === \"object\") {\n                // make directory\n                this._root._walk(path, true);\n                // make content\n                this._init(content, path);\n                return;\n            } else {\n                content = new Buffer(String(content), \"utf-8\");\n            }\n        }\n        directoryNode._entries[base] = fileNode;\n        fileNode._chunks = [content];\n    }, this);\n};\n\nMockFs.prototype.list = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var node = self._root._walk(path)._follow(path);\n        if (!node.isDirectory()) {\n            new Error(\"Can't list non-directory: \" + JSON.stringify(path));\n        }\n        return Object.keys(node._entries).sort();\n    });\n};\n\nMockFs.prototype.open = function (path, flags, charset, options) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var base = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't find \" + path + \" because \" + directory + \" is not a directory\");\n        }\n        if (typeof flags == \"object\") {\n            options = flags;\n            flags = options.flags;\n            charset = options.charset;\n        } else {\n            options = options || {};\n        }\n        flags = flags || \"r\";\n        var binary = flags.indexOf(\"b\") >= 0;\n        var write = flags.indexOf(\"w\") >= 0;\n        if (!binary) {\n            charset = charset || \"utf-8\";\n        }\n        if (write) {\n            if (!node._entries[base]) {\n                node._entries[base] = new FileNode(this);\n            }\n            var fileNode = node._entries[base]._follow(path);\n            if (!fileNode.isFile()) {\n                throw new Error(\"Can't write non-file \" + path);\n            }\n            fileNode._lastModified = new Date();\n            fileNode._lastAccessed = new Date();\n            return new BufferStream(fileNode._chunks, charset);\n        } else { // read\n            if (!node._entries[base]) {\n                throw new Error(\"Can't read non-existant \" + path);\n            }\n            var fileNode = node._entries[base]._follow(path);\n            if (!fileNode.isFile()) {\n                throw new Error(\"Can't read non-file \" + path);\n            }\n            fileNode._lastAccessed = new Date();\n            if (\"begin\" in options && \"end\" in options) {\n                return new BufferStream(\n                    [\n                        Reader.join(fileNode._chunks)\n                        .slice(options.begin, options.end)\n                    ],\n                    charset\n                );\n            } else {\n                return new BufferStream(fileNode._chunks, charset);\n            }\n        }\n    });\n};\n\nMockFs.prototype.remove = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var name = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't remove file from non-directory: \" + path);\n        }\n        if (!node._entries[name]) {\n            throw new Error(\"Can't remove non-existant file: \" + path);\n        }\n        if (node._entries[name].isDirectory()) {\n            throw new Error(\"Can't remove directory. Use removeDirectory: \" + path);\n        }\n        delete node._entries[name];\n    });\n};\n\nMockFs.prototype.makeDirectory = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var name = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            var error =  new Error(\"Can't make directory in non-directory: \" + path);\n            error.code = \"EEXISTS\";\n            error.exists = true;\n            throw error;\n        }\n        if (node._entries[name]) {\n            var error = new Error(\"Can't make directory. Entry exists: \" + path);\n            error.code = \"EISDIR\";\n            error.exists = true;\n            error.isDirectory = true;\n            throw error;\n        }\n        node._entries[name] = new DirectoryNode(self);\n    });\n};\n\nMockFs.prototype.removeDirectory = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var name = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't remove directory from non-directory: \" + path);\n        }\n        if (!node._entries[name]) {\n            throw new Error(\"Can't remove non-existant directory: \" + path);\n        }\n        if (!node._entries[name].isDirectory()) {\n            throw new Error(\"Can't remove non-directory: \" + path);\n        }\n        delete node._entries[name];\n    });\n};\n\nMockFs.prototype.stat = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        return self._root._walk(path)._follow(path);\n    });\n};\n\nMockFs.prototype.statLink = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var node = self._root._walk(path);\n        if (!node.isSymbolicLink()) {\n            throw new Error(\"Path is not symbolic link: \" + JSON.stringify(path));\n        }\n        return node;\n    });\n};\n\nMockFs.prototype.link = function (source, target) {\n    var self = this;\n    return Q.fcall(function () {\n        source = self.absolute(source);\n        target = self.absolute(target);\n        var sourceNode = self._root._walk(source)._follow(source);\n        if (!sourceNode.isFile()) {\n            throw new Error(\"Can't link non-file: \" + source);\n        }\n        var directory = self.directory(target);\n        var base = self.base(target);\n        var targetNode = self._root._walk(directory)._follow(directory);\n        if (!targetNode.isDirectory()) {\n            throw new Error(\"Can't create link in non-directory: \" + target);\n        }\n        if (targetNode._entries[base] && targetNode._entries[base].isDirectory()) {\n            throw new Error(\"Can't overwrite existing directory with hard link: \" + target);\n        }\n        targetNode._entries[base] = sourceNode;\n    });\n};\n\nMockFs.prototype.symbolicLink = function (target, relative, type) {\n    var self = this;\n    return Q.fcall(function () {\n        target = self.absolute(target);\n        var directory = self.directory(target);\n        var base = self.base(target);\n        var node = self._root._walk(directory);\n        if (node._entries[base] && node._entries[base].isDirectory()) {\n            throw new Error(\"Can't overwrite existing directory with symbolic link: \" + target);\n        }\n        node._entries[base] = new LinkNode(self, relative);\n    });\n};\n\nMockFs.prototype.chown = function (path, owner) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        self._root._walk(path)._follow(path)._owner = owner;\n    });\n};\n\nMockFs.prototype.chmod = function (path, mode) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        self._root._walk(path)._follow(path)._mode = mode;\n    });\n};\n\nMockFs.prototype.move = function (source, target) {\n    var self = this;\n    return Q.fcall(function () {\n        source = self.absolute(source);\n        target = self.absolute(target);\n\n        var sourceDirectory = self.directory(source);\n        var sourceDirectoryNode = self._root._walk(sourceDirectory)._follow(sourceDirectory);\n        var sourceName = self.base(source);\n        var sourceNode = sourceDirectoryNode._entries[sourceName];\n\n        if (!sourceNode) {\n            var error = new Error(\"Can't copy non-existent file: \" + source);\n            error.code = \"ENOENT\";\n            throw error;\n        }\n\n        sourceNode = sourceNode._follow(source);\n\n        // check again after following symbolic links\n        if (!sourceNode) {\n            var error = new Error(\"Can't copy non-existent file: \" + source);\n            error.code = \"ENOENT\";\n            throw error;\n        }\n\n        var targetDirectory = self.directory(target);\n        var targetDirectoryNode = self._root._walk(targetDirectory)._follow(targetDirectory);\n        var targetName = self.base(target);\n        var targetNode = targetDirectoryNode._entries[targetName]; // might not exist, not followed\n\n        if (targetNode) {\n            targetNode = targetNode._follow(target);\n        }\n\n        if (targetNode && targetNode.isDirectory()) {\n            var error = new Error(\"Can't copy over existing directory: \" + target);\n            error.code = \"EISDIR\";\n            throw error;\n        }\n\n        // do not copy over self, even with symbolic links to confuse the issue\n        if (targetNode === sourceNode) {\n            return;\n        }\n\n        targetDirectoryNode._entries[targetName] = sourceNode;\n        delete sourceDirectoryNode._entries[sourceName];\n    });\n};\n\nMockFs.prototype.readLink = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var node = self._root._walk(path);\n        if (!self.isSymbolicLink()) {\n            throw new Error(\"Can't read non-symbolic link: \" + path);\n        }\n        return node._link;\n    });\n};\n\nMockFs.prototype.canonical = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        return self._root._canonical(path);\n    });\n};\n\nMockFs.mock = mock;\nfunction mock(fs, root) {\n    return Q.when(fs.listTree(root), function (list) {\n        var tree = {};\n        return Q.all(list.map(function (path) {\n            var actual = fs.join(root, path);\n            var relative = fs.relativeFromDirectory(root, actual);\n            return Q.when(fs.stat(actual), function (stat) {\n                if (stat.isFile()) {\n                    return Q.when(fs.read(path, \"rb\"), function (content) {\n                        tree[relative] = content;\n                    });\n                }\n            });\n        })).then(function () {\n            return MockFs(tree);\n        });\n    });\n}\n\nfunction Node(fs) {\n    if (!fs)\n        throw new Error(\"FS required argument\");\n    this._fs = fs;\n    this._accessed = this._modified = new Date();\n    this._mode = parseInt(\"0644\", 8);\n    this._owner = null;\n}\n\nNode.prototype._walk = function (path, make, via) {\n    var parts = this._fs.split(path);\n    if (this._fs.isAbsolute(path)) {\n        parts.shift();\n        return this._fs._root._walkParts(parts, make, this._fs.ROOT);\n    } else {\n        return this._walkParts(parts, make, via || this._fs.ROOT);\n    }\n};\n\nNode.prototype._walkParts = function (parts, make, via) {\n    if (parts.length === 0) {\n        return this;\n    } else {\n        var part = parts.shift();\n        if (part === \"\") {\n            return this._walkParts(parts, make, this._fs.join(via, part));\n        } else {\n            throw new Error(\"Can't find \" + JSON.stringify(this._fs.resolve(part, this._fs.join(parts))) + \" via \" + JSON.stringify(via));\n        }\n    }\n};\n\nNode.prototype._canonical = function (path) {\n    if (!this._fs.isAbsolute(path)) {\n        throw new Error(\"Path must be absolute for _canonical: \" + path);\n    }\n    var parts = this._fs.split(path);\n    parts.shift();\n    var via = this._fs.ROOT;\n    return via + this._fs._root._canonicalParts(parts, via);\n};\n\nNode.prototype._canonicalParts = function (parts, via) {\n    if (parts.length === 0) {\n        return via;\n    }\n    return this._fs.join(via, this._fs.join(parts));\n};\n\nNode.prototype._follow = function () {\n    return this;\n};\n\nNode.prototype._touch = function () {\n    this._modified = new Date();\n};\n\nvar stats = [\n    \"isDirectory\",\n    \"isFile\",\n    \"isBlockDevice\",\n    \"isCharacterDevice\",\n    \"isSymbolicLink\",\n    \"isFIFO\",\n    \"isSocket\"\n];\n\nstats.forEach(function (name) {\n    Node.prototype[name] = function () {\n        return false;\n    };\n});\n\nNode.prototype.lastAccessed = function () {\n    return this._accessed;\n};\n\nNode.prototype.lastModified = function () {\n    return this._modified;\n};\n\nfunction FileNode(fs) {\n    Node.call(this, fs);\n    this._chunks = [];\n}\n\nFileNode.prototype = Object.create(Node.prototype);\n\nFileNode.prototype.isFile = function () {\n    return true;\n};\n\nfunction DirectoryNode(fs) {\n    Node.call(this, fs);\n    this._entries = Object.create(null);\n    this._mode = parseInt(\"0755\", 8);\n}\n\nDirectoryNode.prototype = Object.create(Node.prototype);\n\nDirectoryNode.prototype.isDirectory = function () {\n    return true;\n};\n\nDirectoryNode.prototype._walkParts = function (parts, make, via) {\n    via = via || this._fs.ROOT;\n    if (parts.length === 0) {\n        return this;\n    }\n    var part = parts.shift();\n    if (part === \"\") {\n        return this._walkParts(parts, make, this._fs.join(via, part));\n    }\n    if (!this._entries[part]) {\n        if (make) {\n            this._entries[part] = new DirectoryNode(this._fs);\n        } else {\n            throw new Error(\"Can't find \" + JSON.stringify(this._fs.join(parts)) + \" via \" + JSON.stringify(via));\n        }\n    }\n    return this._entries[part]._walkParts(parts, make, this._fs.join(via, part));\n};\n\nDirectoryNode.prototype._canonicalParts = function (parts, via) {\n    if (parts.length === 0) {\n        return via;\n    }\n    var part = parts.shift();\n    if (part === \"\") {\n        return via;\n    }\n    if (via === this._fs.ROOT) {\n        via = \"\";\n    }\n    if (!this._entries[part]) {\n        return this._fs.join(via, part, this._fs.join(parts));\n    }\n    return this._entries[part]._canonicalParts(\n        parts,\n        this._fs.join(via, part)\n    );\n};\n\nfunction LinkNode(fs, link) {\n    Node.call(this, fs);\n    this._link = link;\n}\n\nLinkNode.prototype = Object.create(Node.prototype);\n\nLinkNode.prototype.isSymbolicLink = function () {\n    return true;\n};\n\nLinkNode.prototype._follow = function (via, memo) {\n    memo = memo || Set();\n    if (memo.has(this)) {\n        var error = new Error(\"Can't follow symbolic link cycle at \" + JSON.stringify(via));\n        error.code = \"ELOOP\";\n        throw error;\n    }\n    memo.add(this);\n    var link = this._fs.join(via, \"..\", this._link);\n    return this._walk(link, null, \"<link>\")._follow(link, memo);\n};\n\nLinkNode.prototype._canonicalParts = function (parts, via) {\n    return this._fs.relativeFromDirectory(this._fs.ROOT,\n        this._fs._root._canonical(\n            this._fs.absolute(this._fs.join(via, \"..\", this._link))\n        )\n    );\n};\n\n// cycle breaking\nvar FS = require(\"./fs\");","blocks":{"total":117,"seen":80,"missing":37,"percentage":0.6837606837606838}},"hash":"4d2ab4f2ca7a6c88defa17173d3f7881"},"/Users/kris/q-io/buffer-stream.js":{"stats":{"percentage":0.8947368421052632,"lines":[{"lineno":7},{"lineno":10},{"lineno":12},{"lineno":42},{"lineno":55},{"lineno":56}],"missing":6,"seen":51,"total":57,"coverage":{"7":{"partial":false,"source":"        return new BufferStream(chunks, charset);","missing":[{"startCol":8,"endCol":49}]},"10":{"partial":false,"source":"        chunks = [];","missing":[{"startCol":8,"endCol":20}]},"12":{"partial":false,"source":"        chunks = [chunks];","missing":[{"startCol":8,"endCol":26}]},"42":{"partial":false,"source":"            throw new Error(\"Can't write strings to buffer stream without a charset: \" + chunk);","missing":[{"startCol":12,"endCol":96},{"startCol":28,"endCol":94}]},"55":{"partial":false,"source":"    this._close.resolve();","missing":[{"startCol":4,"endCol":25}]},"56":{"partial":false,"source":"    return Q.resolve();","missing":[{"startCol":4,"endCol":23},{"startCol":11,"endCol":22}]}},"source":"var Q = require(\"q\");\nvar Reader = require(\"./reader\");\n\nmodule.exports = BufferStream;\nfunction BufferStream(chunks, charset) {\n    if (!(this instanceof BufferStream)) {\n        return new BufferStream(chunks, charset);\n    }\n    if (!chunks) {\n        chunks = [];\n    } else if (!Array.isArray(chunks)) {\n        chunks = [chunks];\n    }\n    this._charset = charset;\n    this._chunks = chunks;\n    this._close = Q.defer();\n    this.closed = this._close.promise;\n}\n\nBufferStream.prototype.forEach = function (write, thisp) {\n    var self = this;\n    var chunks = self._chunks;\n    return Q.fcall(function () {\n        chunks.splice(0, chunks.length).forEach(write, thisp);\n    });\n};\n\nBufferStream.prototype.read = function () {\n    var result;\n    result = Reader.join(this._chunks);\n    if (this._charset) {\n        result = result.toString(this._charset);\n    }\n    return Q.resolve(result);\n};\n\nBufferStream.prototype.write = function (chunk) {\n    if (this._charset) {\n        chunk = new Buffer(String(chunk), this._charset);\n    } else {\n        if (!(chunk instanceof Buffer)) {\n            throw new Error(\"Can't write strings to buffer stream without a charset: \" + chunk);\n        }\n    }\n    this._chunks.push(chunk);\n    return Q.resolve();\n};\n\nBufferStream.prototype.close = function () {\n    this._close.resolve();\n    return Q.resolve();\n};\n\nBufferStream.prototype.destroy = function () {\n    this._close.resolve();\n    return Q.resolve();\n};","blocks":{"total":14,"seen":9,"missing":5,"percentage":0.6428571428571429}},"hash":"cefdc526b6f9a887b2e346b5864ae9f6"},"/Users/kris/q-io/spec/fs/make-tree-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":85,"total":85,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../fs\");\nvar _n = FS.normal;\n\ndescribe(\"makeTree\", function () {\n    it(\"should make a branch of a tree\", function () {\n\n        return Q.fcall(function () {\n            return FS.makeTree(\"a/b/c\");\n        })\n\n        .then(function () {\n            return FS.listTree(\"a\");\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \"a\",\n                _n(\"a/b\"),\n                _n(\"a/b/c\")\n            ]);\n        })\n\n        .then(function () {\n            return FS.exists(\"a/b/c\");\n        })\n        .then(function (exists) {\n            expect(exists).toBe(true);\n        })\n\n        .then(function () {\n            return FS.isDirectory(\"a/b/c\");\n        })\n        .then(function (isDirectory) {\n            expect(isDirectory).toBe(true);\n        })\n\n    });\n\n    it(\"should make a branch of a tree even if some of it already exists\", function () {\n\n        return Q.fcall(function () {\n            return FS.makeTree(\"a/b/c/d\");\n        })\n\n        .then(function () {\n            return FS.listTree(\"a\");\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \"a\",\n                _n(\"a/b\"),\n                _n(\"a/b/c\"),\n                _n(\"a/b/c/d\")\n            ]);\n        })\n        .then(function () {\n            return FS.removeTree(\"a\");\n        })\n    });\n\n    it(\"should make branch from an absolute path\", function () {\n\n        return Q.fcall(function () {\n            return FS.makeTree(FS.absolute(\"a/b/c/d\"));\n        })\n\n        .then(function () {\n            return FS.listTree(\"a\");\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \"a\",\n                _n(\"a/b\"),\n                _n(\"a/b/c\"),\n                _n(\"a/b/c/d\")\n            ]);\n        })\n        .then(function () {\n            return FS.removeTree(\"a\");\n        })\n    });\n});","blocks":{"total":19,"seen":19,"missing":0,"percentage":1}},"hash":"0e9e4c7d73c75a7a660b160917ba78ad"},"/Users/kris/q-io/spec/fs/mock/append-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":40,"total":40,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n/*global describe,it,expect */\n\ndescribe(\"append\", function () {\n\n    it(\"appends to a file on a mock filesystem\", function () {\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n            return Q.fcall(function () {\n                return mock.append(\"hello.txt\", \"Goodbye!\\n\");\n            })\n            .then(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (contents) {\n                expect(contents).toBe(\"Hello, World!\\nGoodbye!\\n\");\n            });\n        });\n    });\n\n    it(\"calls open correctly\", function () {\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n            mock.open = function (path, options) {\n                expect(path).toBe(\"hello.txt\");\n                expect(options.flags).toBe(\"w+a\");\n                expect(options.charset).toBe(\"utf8\");\n\n                return Q.resolve({write: function () {}, close: function () {}});\n            };\n\n            return mock.append(\"hello.txt\", \"Goodbye!\\n\", \"a\", \"utf8\");\n        });\n    });\n\n});","blocks":{"total":11,"seen":11,"missing":0,"percentage":1}},"hash":"39401e1b2cba0bb5d03044d36aa2e5a0"},"/Users/kris/q-io/spec/fs/mock/copy-tree-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":56,"total":56,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\nvar normalize = FS.normal;\n\ndescribe(\"copyTree\", function () {\n    it(\"should copy a tree\", function () {\n\n        var mock = Mock({\n            \"a/b\": {\n                \"c\": {\n                    \"d\": 66,\n                    \"e\": 99\n                }\n            }\n        });\n\n        return Q.fcall(function () {\n            return mock.copyTree(\"a/b\", \"a/f\");\n        })\n        .then(function () {\n            return Q.all([\n                mock.isDirectory(\"a/f\"),\n                mock.exists(\"a/f/c\"),\n                mock.isFile(\"a/f/c/d\"),\n                mock.read(\"a/f/c/e\")\n            ])\n        })\n        .then(function (existence) {\n            expect(existence.every(Boolean)).toBe(true);\n        })\n\n        .then(function () {\n            return mock.listTree();\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"a\",\n                normalize(\"a/b\"),\n                normalize(\"a/b/c\"),\n                normalize(\"a/b/c/d\"),\n                normalize(\"a/b/c/e\"),\n                normalize(\"a/f\"),\n                normalize(\"a/f/c\"),\n                normalize(\"a/f/c/d\"),\n                normalize(\"a/f/c/e\")\n            ]);\n        })\n\n    });\n\n});","blocks":{"total":7,"seen":7,"missing":0,"percentage":1}},"hash":"c87c363cff5a8e60132f77e64bc9bcb7"},"/Users/kris/q-io/spec/fs/mock/link-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":67,"total":67,"coverage":{},"source":"require(\"../../lib/jasmine-promise\");\nvar MockFs = require(\"../../../fs-mock\");\nvar normalize = require('../../../fs').normal;\n\ndescribe(\"link\", function () {\n    it(\"should\", function () {\n        var mock = MockFs();\n\n        // make some content\n        return mock.makeTree(\"a/b\")\n        .then(function () {\n            return mock.write(\"a/b/c.txt\", \"Hello, World!\")\n        })\n\n        // verify content\n        .then(function () {\n            return mock.read(\"a/b/c.txt\")\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        })\n\n        // link it\n        .then(function () {\n            return mock.link(\"a/b/c.txt\", \"a/b/d.txt\")\n        })\n\n        // should be non-destructive\n        .then(function () {\n            return mock.read(\"a/b/c.txt\")\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        })\n\n        // should be listed\n        .then(function () {\n            return mock.listTree()\n        })\n        .then(function (content) {\n            expect(content).toEqual([\n                \".\",\n                \"a\",\n                normalize(\"a/b\"),\n                normalize(\"a/b/c.txt\"),\n                normalize(\"a/b/d.txt\")\n            ])\n        })\n\n        // should be identified as a file\n        .then(function () {\n            return mock.isFile(\"a/b/d.txt\");\n        })\n        .then(function (isFile) {\n            expect(isFile).toBe(true);\n        })\n\n        // should have the same content\n        .then(function () {\n            return mock.read(\"a/b/d.txt\");\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        });\n\n    });\n});","blocks":{"total":14,"seen":14,"missing":0,"percentage":1}},"hash":"101065f24b6a07a42ee8954c3d801d48"},"/Users/kris/q-io/spec/fs/mock/make-tree-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":108,"total":108,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\nvar normalize = FS.normal;\n\ndescribe(\"makeTree\", function () {\n    it(\"should make a branch of a tree\", function () {\n\n        var mock = Mock({\n            \"a\": {}\n        });\n\n        return Q.fcall(function () {\n            return mock.makeTree(\"a/b/c\");\n        })\n\n        .then(function () {\n            return mock.listTree();\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"a\",\n                normalize(\"a/b\"),\n                normalize(\"a/b/c\")\n            ]);\n        })\n\n        .then(function () {\n            return mock.exists(\"a/b/c\")\n        })\n        .then(function (exists) {\n            expect(exists).toBe(true);\n        })\n\n        .then(function () {\n            return mock.isDirectory(\"a/b/c\")\n        })\n        .then(function (isDirectory) {\n            expect(isDirectory).toBe(true);\n        })\n\n    });\n\n    it(\"should make a branch of a tree even if some of it already exists\", function () {\n\n        var mock = Mock({\n            \"a/b\": {}\n        });\n\n        return Q.fcall(function () {\n            return mock.makeTree(\"a/b/c/d\");\n        })\n\n        .then(function () {\n            return mock.listTree();\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"a\",\n                normalize(\"a/b\"),\n                normalize(\"a/b/c\"),\n                normalize(\"a/b/c/d\")\n            ]);\n        })\n    });\n\n    it(\"should make an absolute tree from a subdirectory\", function () {\n        var mock = Mock({\n            \"a/b\": {\n                \"c\": {\n                    \"d.ext\": 66\n                }\n            }\n        }, \"/a/b\");\n\n        return Q.fcall(function () {\n            return mock.makeTree(\"/a/b/c/x/y/z\");\n        })\n        .then(function () {\n            return Q.all([\n                mock.isDirectory(\"a/b/c/x\"),\n                mock.isDirectory(\"a/b/c/x/y\"),\n                mock.isDirectory(\"a/b/c/x/y/z\")\n            ]);\n        })\n        .then(function () {\n            return mock.listTree(\"/\");\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \"/\",\n                \"/a\",\n                \"/a/b\",\n                \"/a/b/c\",\n                \"/a/b/c/d.ext\",\n                \"/a/b/c/x\",\n                \"/a/b/c/x/y\",\n                \"/a/b/c/x/y/z\"\n            ]);\n        });\n    });\n\n});","blocks":{"total":18,"seen":18,"missing":0,"percentage":1}},"hash":"a1c7e97d4755b112212980d6ab4c7ca0"},"/Users/kris/q-io/spec/fs/mock/merge-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":66,"total":66,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\nvar normalize = FS.normal;\n\ndescribe(\"makeTree\", function () {\n    it(\"should make a branch of a tree\", function () {\n\n        var merged = FS.merge([\n            Mock({\n                \"a\": 10,\n                \"b\": 20,\n                \"1/2/3\": \"123\"\n            }),\n            Mock({\n                \"a\": 20,\n                \"c\": 30\n            }),\n            Mock({\n                \"a\": 30,\n                \"d\": 40\n            }),\n        ])\n\n        return merged.then(function (merged) {\n\n            return Q.fcall(function () {\n                return merged.listTree();\n            })\n            .then(function (list) {\n                expect(list.sort()).toEqual([\n                    \".\",\n                    \"1\",\n                    normalize(\"1/2\"),\n                    normalize(\"1/2/3\"),\n                    \"a\",\n                    \"b\",\n                    \"c\",\n                    \"d\",\n                ]);\n            })\n\n            // overridden by a previous tree\n            .then(function () {\n                return merged.read(\"a\");\n            })\n            .then(function (a) {\n                expect(a).toBe(\"30\");\n            })\n\n            // not overridden\n            .then(function () {\n                return merged.read(\"b\");\n            })\n            .then(function (a) {\n                expect(a).toBe(\"20\");\n            })\n\n        })\n\n    });\n\n});","blocks":{"total":9,"seen":9,"missing":0,"percentage":1}},"hash":"2b703cbff03f658b0e619e82b43277e2"},"/Users/kris/q-io/spec/fs/mock/move-spec.js":{"stats":{"percentage":0.9908256880733946,"lines":[{"lineno":190},{"lineno":212}],"missing":2,"seen":216,"total":218,"coverage":{"190":{"partial":false,"source":"            throw new Error(\"Move should not succeed.\");","missing":[{"startCol":12,"endCol":56}]},"212":{"partial":false,"source":"            throw new Error(\"Move should not succeed.\");","missing":[{"startCol":12,"endCol":56}]}},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\n\ndescribe(\"move\", function () {\n    it(\"should move\", function () {\n\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            // initial list\n            return Q.fcall(function () {\n                return mock.listTree()\n            })\n            .then(function (list) {\n                expect(list).toEqual([\n                    \".\",\n                    \"hello.txt\"\n                ]);\n            })\n\n            // initial content\n            .then(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n\n            // move!\n            .then(function () {\n                return mock.move(\"hello.txt\", \"new-hello.txt\");\n            })\n\n            // list after\n            .then(function () {\n                return mock.listTree();\n            })\n            .then(function (list) {\n                expect(list).toEqual([\n                    \".\",\n                    \"new-hello.txt\"\n                ]);\n            })\n\n            // content after\n            .then(function () {\n                return mock.read(\"new-hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n\n        });\n    });\n\n    it(\"should not delete a node if the source and target are the same\", function () {\n\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            // initial list\n            return Q.fcall(function () {\n                return mock.listTree()\n            })\n            .then(function (list) {\n                expect(list).toEqual([\n                    \".\",\n                    \"hello.txt\"\n                ]);\n            })\n\n            // initial content\n            .then(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n\n            // move!\n            .then(function () {\n                return mock.move(\"hello.txt\", \"hello.txt\");\n            })\n\n            // list after\n            .then(function () {\n                return mock.listTree();\n            })\n            .then(function (list) {\n                expect(list).toEqual([\n                    \".\",\n                    \"hello.txt\"\n                ]);\n            })\n\n            // content after\n            .then(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n        });\n\n    });\n\n    it(\"should not delete a node if the source and target refer to the same node\", function () {\n\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            return Q.fcall(function () {\n                return Q.all([\n                    mock.symbolicCopy(\"hello.txt\", \"a.txt\"),\n                    mock.symbolicCopy(\"hello.txt\", \"b.txt\"),\n                ]);\n            })\n\n            // initial list\n            .then(function () {\n                return mock.listTree()\n            })\n            .then(function (list) {\n                expect(list).toEqual([\n                    \".\",\n                    \"a.txt\",\n                    \"b.txt\",\n                    \"hello.txt\"\n                ]);\n            })\n\n            // initial content\n            .then(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n\n            // move!\n            .then(function () {\n                return mock.move(\"a.txt\", \"b.txt\");\n            })\n\n            // list after\n            .then(function () {\n                return mock.listTree();\n            })\n            .then(function (list) {\n                expect(list).toEqual([\n                    \".\",\n                    \"a.txt\",\n                    \"b.txt\",\n                    \"hello.txt\"\n                ]);\n            })\n\n            // content after\n            .then(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n        });\n\n    });\n\n    it(\"should fail to move over an existing directory\", function () {\n        var mock = Mock({\n            \"hi.txt\": \"Hello, World!\",\n            \"hello\": {}\n        });\n\n        return Q.fcall(function () {\n            return mock.isDirectory(\"/hello\");\n        })\n        .then(function (isDirectory) {\n            expect(isDirectory).toBe(true);\n        })\n\n        .then(function () {\n            return mock.move(\"/hi.txt\", \"/hello\");\n        })\n        .then(function () {\n            throw new Error(\"Move should not succeed.\");\n        }, function (error) {\n        })\n\n    });\n\n    it(\"should fail to move over an existing directory of the same name\", function () {\n        var mock = Mock({\n            \"hello\": {}\n        });\n\n        return Q.fcall(function () {\n            return mock.isDirectory(\"/hello\");\n        })\n        .then(function (isDirectory) {\n            expect(isDirectory).toBe(true);\n        })\n\n        .then(function () {\n            return mock.move(\"/hello\", \"/hello\");\n        })\n        .then(function () {\n            throw new Error(\"Move should not succeed.\");\n        }, function (error) {\n        })\n\n    });\n\n});","blocks":{"total":47,"seen":45,"missing":2,"percentage":0.9574468085106383}},"hash":"62b7376a4f8a786ebe49ba5c7e66f207"},"/Users/kris/q-io/spec/fs/mock/object-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":19,"total":19,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n\ndescribe(\"toObject\", function () {\n    it(\"should take a snapshot of a tree\", function () {\n\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .invoke(\"toObject\")\n        .then(function (tree) {\n\n            expect(tree[\"hello.txt\"].toString(\"utf-8\")).toEqual(\"Hello, World!\\n\");\n            expect(Object.keys(tree)).toEqual([\"hello.txt\"]);\n\n        });\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"6ff4b49e7a83c9d339b5a47180f84047"},"/Users/kris/q-io/spec/fs/mock/range-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":25,"total":25,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\n\ndescribe(\"open range\", function () {\n    it(\"read a partial range of a file\", function () {\n\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            return mock.read(\"hello.txt\", {\n                begin: 1,\n                end: 3\n            })\n            .then(function (content) {\n                expect(content).toBe(\"el\");\n            })\n\n        });\n\n    });\n});","blocks":{"total":4,"seen":4,"missing":0,"percentage":1}},"hash":"a53e87155446bc253642a4ff9ea35692"},"/Users/kris/q-io/spec/fs/mock/read-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":39,"total":39,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n/*global describe,it,expect */\n\ndescribe(\"read\", function () {\n    it(\"should read a file from a mock filesystem\", function () {\n\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            return Q.fcall(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n\n        });\n    });\n\n    it(\"calls open correctly\", function () {\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n            mock.open = function (path, options) {\n                expect(path).toBe(\"hello.txt\");\n                expect(options.flags).toBe(\"ra\");\n                expect(options.charset).toBe(\"utf8\");\n\n                return Q.resolve({read: function () {}, close: function () {}});\n            };\n\n            return mock.read(\"hello.txt\", \"a\", \"utf8\");\n        });\n    });\n\n});","blocks":{"total":10,"seen":9,"missing":1,"percentage":0.9}},"hash":"838f3490148f610ae66aecd3755d1b3e"},"/Users/kris/q-io/spec/fs/mock/remove-directory-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":36,"total":36,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n\ndescribe(\"removeDirectory\", function () {\n    it(\"should remove a directory\", function () {\n\n        return FS.mock(FS.join(__dirname))\n        .then(function (mock) {\n\n            // now you see it\n            return Q.fcall(function () {\n                return mock.isDirectory(\"fixture\");\n            })\n            .then(function (isDirectory) {\n                expect(isDirectory).toBe(true);\n            })\n\n            .then(function () {\n                return mock.removeDirectory(\"fixture\");\n            })\n\n            // now you don't\n            .then(function () {\n                return mock.isDirectory(\"fixture\");\n            })\n            .then(function (isDirectory) {\n                expect(isDirectory).toBe(false);\n            })\n\n        });\n\n    });\n});","blocks":{"total":8,"seen":8,"missing":0,"percentage":1}},"hash":"b3f3583fd1eeaaa5ef565a73c2f2a26e"},"/Users/kris/q-io/spec/fs/mock/remove-tree-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":38,"total":38,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\nvar normalize = FS.normal;\n\ndescribe(\"removeTree\", function () {\n    it(\"should remove a tree\", function () {\n\n        var mock = Mock({\n            \"a/b\": {\n                \"c\": {\n                    \"d\": 66,\n                    \"e\": 99\n                }\n            }\n        });\n\n        return Q.fcall(function () {\n            return mock.removeTree(\"a/b/c\");\n        })\n\n        .then(function () {\n            return mock.listTree();\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"a\",\n                normalize(\"a/b\")\n            ]);\n        })\n\n    });\n\n});","blocks":{"total":5,"seen":5,"missing":0,"percentage":1}},"hash":"c9a2ac2b44830af6b1b22a1e1c617e08"},"/Users/kris/q-io/spec/fs/mock/root-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":31,"total":31,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\nvar Root = require(\"../../../fs-root\");\n\ndescribe(\"root\", function () {\n    it(\"should make a filesystem from a subtree of a mock filesystem\", function () {\n\n        var mock = Mock({\n            \"a/b/1\": 10,\n            \"a/b/2\": 20,\n            \"a/b/3\": 30\n        });\n\n        var chroot = Root(mock, \"a/b\");\n\n        return chroot.invoke(\"listTree\")\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"1\",\n                \"2\",\n                \"3\"\n            ]);\n        });\n\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"eea3a69862bc928fb03397376a95f540"},"/Users/kris/q-io/spec/fs/mock/symbolic-link-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":83,"total":83,"coverage":{},"source":"require(\"../../lib/jasmine-promise\");\nvar MockFs = require(\"../../../fs-mock\");\nvar normalize = require('../../../fs').normal;\n\ndescribe(\"symbolic link\", function () {\n    it(\"should\", function () {\n        var mock = MockFs();\n\n        // make some content\n        return mock.makeTree(\"a/b\")\n        .then(function () {\n            return mock.write(\"a/b/c.txt\", \"Hello, World!\")\n        })\n\n        // verify content\n        .then(function () {\n            return mock.read(\"a/b/c.txt\")\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        })\n\n        // link it\n        .then(function () {\n            return mock.symbolicCopy(\"/a/b/c.txt\", \"a/b/d.txt\", \"file\")\n        })\n\n        // should have a link\n        .then(function () {\n            return mock.readLink(\"a/b/d.txt\")\n        })\n        .then(function (link) {\n            expect(link).toBe(\"c.txt\");\n        })\n\n        // should have a canonical path\n        .then(function () {\n            return mock.canonical(\"a/b/d.txt\")\n        })\n        .then(function (canonical) {\n            expect(canonical).toBe(\"/a/b/c.txt\");\n        })\n\n        // should be listed\n        .then(function () {\n            return mock.listTree()\n        })\n        .then(function (content) {\n            expect(content).toEqual([\n                \".\",\n                \"a\",\n                normalize(\"a/b\"),\n                normalize(\"a/b/c.txt\"),\n                normalize(\"a/b/d.txt\")\n            ])\n        })\n\n        // should be non-destructive\n        .then(function () {\n            return mock.read(\"a/b/c.txt\")\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        })\n\n        // should be identified as a file\n        .then(function () {\n            return mock.isSymbolicLink(\"a/b/d.txt\");\n        })\n        .then(function (isSymbolicLink) {\n            expect(isSymbolicLink).toBe(true);\n        })\n\n        // should have the same content\n        .then(function () {\n            return mock.read(\"a/b/d.txt\");\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        });\n\n    });\n});","blocks":{"total":18,"seen":18,"missing":0,"percentage":1}},"hash":"841d1c9c0650fcd6e35d3f7ccda562a1"},"/Users/kris/q-io/spec/fs/mock/working-directory-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":30,"total":30,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar Mock = require(\"../../../fs-mock\");\n\ndescribe(\"mock working directory\", function () {\n    it(\"should perform actions relative to the given working directory\", function () {\n\n        var mock = Mock({\n            \"a/b\": {\n                \"c\": {\n                    \"d\": 66,\n                    \"e\": 99\n                }\n            }\n        }, \"a/b/c\");\n\n        return mock.listTree()\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"d\",\n                \"e\"\n            ]);\n        })\n\n    });\n\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"9ff3f9732f0a14293f7fcc2e19997009"},"/Users/kris/q-io/spec/fs/mock/write-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":68,"total":68,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n/*global describe,it,expect */\n\ndescribe(\"write\", function () {\n    it(\"should write a file to a mock filesystem\", function () {\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            return Q.fcall(function () {\n                return mock.write(\"hello.txt\", \"Goodbye!\\n\");\n            })\n            .then(function () {\n                return mock.isFile(\"hello.txt\");\n            })\n            .then(function (isFile) {\n                expect(isFile).toBe(true);\n            });\n        });\n    });\n\n    it(\"takes a flags argument\", function () {\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n            return Q.fcall(function () {\n                return mock.write(\"hello.txt\", \"Goodbye!\\n\", \"a\");\n            })\n            .then(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (contents) {\n                expect(contents).toBe(\"Hello, World!\\nGoodbye!\\n\");\n            });\n        });\n    });\n\n    it(\"takes an options object with flags\", function () {\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n            return Q.fcall(function () {\n                return mock.write(\"hello.txt\", \"Goodbye!\\n\", { flags: \"a\" });\n            })\n            .then(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (contents) {\n                expect(contents).toBe(\"Hello, World!\\nGoodbye!\\n\");\n            });\n        });\n    });\n\n    it(\"calls open correctly\", function () {\n        return FS.mock(FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n            mock.open = function (path, options) {\n                expect(path).toBe(\"hello.txt\");\n                expect(options.flags).toBe(\"wa\");\n                expect(options.charset).toBe(\"utf8\");\n                return Q.resolve({write: function () {}, close: function () {}});\n            };\n\n            return mock.write(\"hello.txt\", \"Goodbye!\\n\", \"a\", \"utf8\");\n        });\n    });\n});","blocks":{"total":21,"seen":21,"missing":0,"percentage":1}},"hash":"7e07490f39a76c2a9c929a2727c08fc8"},"/Users/kris/q-io/spec/fs/range-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":22,"total":22,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../fs\");\n\ndescribe(\"open range\", function () {\n    it(\"read a partial range of a file\", function () {\n\n        var name = FS.join(module.directory || __dirname, \"range-spec.txt\");\n\n        return FS.open(name, {\n            begin: 1,\n            end: 3\n        })\n        .invoke(\"read\")\n        .then(function (content) {\n            expect(content).toBe(\"23\");\n        })\n\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"56b279f509eb873fc332e9d6a13b5869"},"/Users/kris/q-io/spec/fs/relative-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":24,"total":24,"coverage":{},"source":"var FS = require(\"../../fs\");\n\ndescribe(\"relativeFromDirectory\", function () {\n\n    it(\"should find the relative path from a directory\", function () {\n\n        expect(FS.relativeFromDirectory(\"/a/b\", \"/a/b\")).toBe(\"\");\n        expect(FS.relativeFromDirectory(\"/a/b/\", \"/a/b\")).toBe(\"\");\n        expect(FS.relativeFromDirectory(\"/a/b\", \"/a/b/\")).toBe(\"\");\n        expect(FS.relativeFromDirectory(\"/a/b/\", \"/a/b/\")).toBe(\"\");\n\n        expect(FS.relativeFromDirectory(\"/a/b\", \"/a/b/c\")).toBe(\"c\");\n        expect(FS.relativeFromDirectory(\"/a/b/\", \"/a/b/c\")).toBe(\"c\");\n        expect(FS.relativeFromDirectory(\"/a/b\", \"/a/b/c/\")).toBe(\"c\");\n        expect(FS.relativeFromDirectory(\"/a/b/\", \"/a/b/c/\")).toBe(\"c\");\n\n        expect(FS.relativeFromDirectory(\"/a/b\", \"/a\")).toBe(\"..\");\n        expect(FS.relativeFromDirectory(\"/a/b/\", \"/a\")).toBe(\"..\");\n        expect(FS.relativeFromDirectory(\"/a/b\", \"/a/\")).toBe(\"..\");\n        expect(FS.relativeFromDirectory(\"/a/b/\", \"/a/\")).toBe(\"..\");\n\n    });\n\n});","blocks":{"total":2,"seen":2,"missing":0,"percentage":1}},"hash":"a311eb73c505ad327e709d39efce923f"},"/Users/kris/q-io/spec/http-apps/cookie-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":50,"total":50,"coverage":{},"source":"require(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar Http = require(\"../../http\");\nvar Apps = require(\"../../http-apps\");\n\ndescribe(\"http cookies\", function () {\n\n    var hosts = [\"localhost\", \"127.0.0.1\"];\n\n    hosts.forEach(function (host) {\n        it(\"should work on host\" + host, function () {\n\n            var server = Http.Server(function (request) {\n                return {\n                    status: 200,\n                    headers: {\n                        \"set-cookie\": \"a=10; MaxAge=1\"\n                    },\n                    body: [request.headers.cookie || \"\"]\n                };\n            });\n\n            var request = Apps.Normalize(Apps.CookieJar(Http.request));\n\n            return server.listen(0)\n            .then(function (server) {\n                var address = server.node.address();\n                return request(\"http://\" + host + \":\" + address.port)\n                .get(\"body\")\n                .invoke(\"read\")\n                .invoke(\"toString\", \"utf-8\")\n                .then(function (content) {\n                    expect(content).toEqual(\"\"); // no cookie first time\n                })\n                .then(function () {\n                    return request(\"http://\" + host + \":\" + address.port)\n                    .get(\"body\")\n                    .invoke(\"read\")\n                    .invoke(\"toString\", \"utf-8\")\n                })\n                .then(function (content) {\n                    expect(content).toEqual(\"a=10\"); // cookie set second time\n                })\n            })\n            .timeout(1000)\n            .finally(server.stop)\n        });\n    });\n\n});","blocks":{"total":8,"seen":8,"missing":0,"percentage":1}},"hash":"5e750c3836f40ec27dc74aa9a2de0dbb"},"/Users/kris/q-io/http.js":{"stats":{"percentage":0.9320652173913043,"lines":[{"lineno":34},{"lineno":43},{"lineno":48},{"lineno":61},{"lineno":81},{"lineno":94},{"lineno":114},{"lineno":129},{"lineno":148},{"lineno":154},{"lineno":195},{"lineno":243},{"lineno":246},{"lineno":249},{"lineno":272},{"lineno":280},{"lineno":289},{"lineno":290},{"lineno":295},{"lineno":302},{"lineno":303},{"lineno":304},{"lineno":336},{"lineno":337},{"lineno":338}],"missing":25,"seen":343,"total":368,"coverage":{"34":{"partial":false,"source":"                closed.reject(error);","missing":[{"startCol":16,"endCol":36}]},"43":{"partial":false,"source":"                    return;","missing":[{"startCol":20,"endCol":27}]},"48":{"partial":false,"source":"                    Q.when(closed, response.onclose || response.onClose);","missing":[{"startCol":20,"endCol":72},{"startCol":35,"endCol":71}]},"61":{"partial":false,"source":"                                _response.write(chunk, response.charset);","missing":[{"startCol":32,"endCol":72}]},"81":{"partial":false,"source":"                        _response.end();","missing":[{"startCol":24,"endCol":39}]},"94":{"partial":false,"source":"            stopped.reject(err);","missing":[{"startCol":12,"endCol":31}]},"114":{"partial":false,"source":"            listening.reject(err);","missing":[{"startCol":12,"endCol":33}]},"129":{"partial":false,"source":"            return Q.reject(new Error(\"A server cannot be restarted or \" +","missing":[{}]},"130":{"partial":false,"source":"            \"started on a new port\"));","missing":[{}]},"148":{"partial":false,"source":"            return this.node.port;","missing":[{"startCol":12,"endCol":34}]},"154":{"partial":false,"source":"            return this.node.host;","missing":[{"startCol":12,"endCol":34}]},"195":{"partial":true,"source":"        port: request.port === (ssl ? 443 : 80) ? null : request.port,","missing":[{"startCol":38,"endCol":41},{"startCol":50,"endCol":54}]},"243":{"partial":false,"source":"        return;","missing":[{"startCol":8,"endCol":15}]},"246":{"partial":false,"source":"        response = [response];","missing":[{"startCol":8,"endCol":30}]},"249":{"partial":false,"source":"        response = {","missing":[{}]},"250":{"partial":false,"source":"            status: 200,","missing":[{}]},"251":{"partial":false,"source":"            headers: {},","missing":[{}]},"252":{"partial":false,"source":"            body: response","missing":[{}]},"253":{"partial":false,"source":"        }","missing":[{}]},"254":{"partial":false,"source":"    }","missing":[{}]},"272":{"partial":true,"source":"        var http = ssl ? HTTPS : HTTP;","missing":[{"startCol":25,"endCol":30}]},"280":{"partial":true,"source":"            \"port\": request.port || (ssl ? 443 : 80),","missing":[{"startCol":43,"endCol":46},{"startCol":49,"endCol":51}]},"289":{"partial":false,"source":"                console.warn(error && error.stack || error);","missing":[{"startCol":16,"endCol":59},{"startCol":29,"endCol":49}]},"290":{"partial":false,"source":"                deferred.reject(error);","missing":[{"startCol":16,"endCol":38}]},"295":{"partial":false,"source":"            deferred.reject(error);","missing":[{"startCol":12,"endCol":34}]},"302":{"partial":false,"source":"                    end = Q.when(end, function () {","missing":[{}]},"303":{"partial":false,"source":"                        return Q.when(chunk, function (chunk) {","missing":[{}]},"304":{"partial":false,"source":"                            _request.write(chunk, request.charset);","missing":[{"startCol":28,"endCol":67},{}]},"305":{"partial":false,"source":"                        });","missing":[{}]},"306":{"partial":false,"source":"                    });","missing":[{}]},"336":{"partial":false,"source":"            var error = new Error(\"HTTP request failed with code \" + response.status);","missing":[{"startCol":12,"endCol":86},{"startCol":34,"endCol":84}]},"337":{"partial":false,"source":"            error.response = response;","missing":[{"startCol":12,"endCol":38}]},"338":{"partial":false,"source":"            throw error;","missing":[{"startCol":12,"endCol":24}]}},"source":"/**\n * A promise-based Q-JSGI server and client API.\n * @module\n */\n\n/*whatsupdoc*/\n\nvar HTTP = require(\"http\"); // node\nvar HTTPS = require(\"https\"); // node\nvar URL = require(\"url2\"); // node\nvar Q = require(\"q\");\nvar Reader = require(\"./reader\");\n\n/**\n * @param {respond(request Request)} respond a JSGI responder function that\n * receives a Request object as its argument.  The JSGI responder promises to\n * return an object of the form `{status, headers, body}`.  The status and\n * headers must be fully resolved, but the body may be a promise for an object\n * with a `forEach(write(chunk String))` method, albeit an array of strings.\n * The `forEach` method may promise to resolve when all chunks have been\n * written.\n * @returns a Node Server object.\n */\nexports.Server = function (respond) {\n    var self = Object.create(exports.Server.prototype);\n\n    var server = HTTP.createServer(function (_request, _response) {\n        var request = exports.ServerRequest(_request);\n        var response = exports.ServerResponse(_response);\n\n        var closed = Q.defer();\n        _request.on(\"end\", function (error, value) {\n            if (error) {\n                closed.reject(error);\n            } else {\n                closed.resolve(value);\n            }\n        });\n\n        Q.when(request, function (request) {\n            return Q.when(respond(request, response), function (response) {\n                if (!response)\n                    return;\n\n                _response.writeHead(response.status, response.headers);\n\n                if (response.onclose || response.onClose)\n                    Q.when(closed, response.onclose || response.onClose);\n\n                return Q.when(response.body, function (body) {\n                    var length;\n                    if (\n                        Array.isArray(body) &&\n                        (length = body.length) &&\n                        body.every(function (chunk) {\n                            return typeof chunk === \"string\"\n                        })\n                    ) {\n                        body.forEach(function (chunk, i) {\n                            if (i < length - 1) {\n                                _response.write(chunk, response.charset);\n                            } else {\n                                _response.end(chunk, response.charset);\n                            }\n                        });\n                    } else if (body) {\n                        var end;\n                        var done = body.forEach(function (chunk) {\n                            end = Q.when(end, function () {\n                                return Q.when(chunk, function (chunk) {\n                                    _response.write(chunk, response.charset);\n                                });\n                            });\n                        });\n                        return Q.when(done, function () {\n                            return Q.when(end, function () {\n                                _response.end();\n                            });\n                        });\n                    } else {\n                        _response.end();\n                    }\n                });\n\n            })\n        })\n        .done(); // should be .fail(self.emitter(\"error\"))\n\n    });\n\n    var stopped = Q.defer();\n    server.on(\"close\", function (err) {\n        if (err) {\n            stopped.reject(err);\n        } else {\n            stopped.resolve();\n        }\n    });\n\n    /***\n     * Stops the server.\n     * @returns {Promise * Undefined} a promise that will\n     * resolve when the server is stopped.\n     */\n    self.stop = function () {\n        server.close();\n        listening = undefined;\n        return stopped.promise;\n    };\n\n    var listening = Q.defer();\n    server.on(\"listening\", function (err) {\n        if (err) {\n            listening.reject(err);\n        } else {\n            listening.resolve(self);\n        }\n    });\n\n    /***\n     * Starts the server, listening on the given port\n     * @param {Number} port\n     * @returns {Promise * Undefined} a promise that will\n     * resolve when the server is ready to receive\n     * connections\n     */\n    self.listen = function (/*...args*/) {\n        if (typeof server.port !== \"undefined\")\n            return Q.reject(new Error(\"A server cannot be restarted or \" +\n            \"started on a new port\"));\n        server.listen.apply(server, arguments);\n        return listening.promise;\n    };\n\n    self.stopped = stopped.promise;\n\n    self.node = server;\n    self.nodeServer = server; // Deprecated\n    self.address = server.address.bind(server);\n\n    return self;\n};\n\nObject.defineProperties(exports.Server, {\n\n    port: {\n        get: function () {\n            return this.node.port;\n        }\n    },\n\n    host: {\n        get: function () {\n            return this.node.host;\n        }\n    }\n\n});\n\n/**\n * A wrapper for a Node HTTP Request, as received by\n * the Q HTTP Server, suitable for use by the Q HTTP Client.\n */\nexports.ServerRequest = function (_request, ssl) {\n    var request = Object.create(_request);\n    /*** {Array} HTTP version. (JSGI) */\n    request.version = _request.httpVersion.split(\".\").map(Math.floor);\n    /*** {String} HTTP method, e.g., `\"GET\"` (JSGI) */\n    request.method = _request.method;\n    /*** {String} path, starting with `\"/\"` */\n    request.path = _request.url;\n    /*** {String} pathInfo, starting with `\"/\"`, the\n     * portion of the path that has not yet\n     * been routed (JSGI) */\n    request.pathInfo = URL.parse(_request.url).pathname;\n    /*** {String} scriptName, the portion of the path that\n     * has already been routed (JSGI) */\n    request.scriptName = \"\";\n    /*** {String} (JSGI) */\n    request.scheme = \"http\";\n\n    request.host = _request.headers.host;\n    request.port = _request.connection.address().port;\n\n    var socket = _request.socket;\n    /*** {String} */\n    request.remoteHost = socket.remoteAddress;\n    /*** {Number} */\n    request.remotePort = socket.remotePort;\n\n    /*** {String} url */\n    request.url = URL.format({\n        protocol: request.scheme,\n        host: _request.headers.host,\n        port: request.port === (ssl ? 443 : 80) ? null : request.port,\n        path: request.path\n    });\n    /*** A Q IO asynchronous text reader */\n    request.body = Reader(_request);\n    /*** {Object} HTTP headers (JSGI)*/\n    request.headers = _request.headers;\n    /*** The underlying Node request */\n    request.node = _request;\n    request.nodeRequest = _request; // Deprecated\n    /*** The underlying Node TCP connection */\n    request.nodeConnection = _request.connection;\n\n    return Q.when(request.body, function (body) {\n        request.body = body;\n        return request;\n    });\n};\n\nexports.ServerResponse = function (_response, ssl) {\n    var response = Object.create(_response);\n    response.ssl = ssl;\n    response.node = _response;\n    response.nodeResponse = _response; // Deprecated\n    return response;\n};\n\nexports.normalizeRequest = function (request) {\n    if (typeof request === \"string\") {\n        request = {\n            url: request\n        };\n    }\n    if (request.url) {\n        var url = URL.parse(request.url);\n        request.host = url.hostname;\n        request.port = url.port;\n        request.ssl = url.protocol === \"https:\";\n        request.method = request.method || \"GET\";\n        request.path = (url.pathname || \"\") + (url.search || \"\");\n        request.headers = request.headers || {};\n        request.headers.host = url.hostname; // FIXME name consistency\n    }\n    return request;\n};\n\nexports.normalizeResponse = function (response) {\n    if (response === void 0) {\n        return;\n    }\n    if (typeof response == \"string\") {\n        response = [response];\n    }\n    if (response.forEach) {\n        response = {\n            status: 200,\n            headers: {},\n            body: response\n        }\n    }\n    return response;\n};\n\n/**\n * Issues an HTTP request.\n *\n * @param {Request {host, port, method, path, headers,\n * body}} request (may be a promise)\n * @returns {Promise * Response} promise for a response\n */\nexports.request = function (request) {\n    return Q.when(request, function (request) {\n\n        request = exports.normalizeRequest(request);\n\n        var deferred = Q.defer();\n        var ssl = request.ssl;\n        var http = ssl ? HTTPS : HTTP;\n\n        var headers = request.headers || {};\n\n        headers.host = headers.host || request.host;\n\n        var _request = http.request({\n            \"host\": request.host,\n            \"port\": request.port || (ssl ? 443 : 80),\n            \"path\": request.path || \"/\",\n            \"method\": request.method || \"GET\",\n            \"headers\": headers\n        }, function (_response) {\n            deferred.resolve(exports.ClientResponse(_response, request.charset));\n            _response.on(\"error\", function (error) {\n                // TODO find a better way to channel\n                // this into the response\n                console.warn(error && error.stack || error);\n                deferred.reject(error);\n            });\n        });\n\n        _request.on(\"error\", function (error) {\n            deferred.reject(error);\n        });\n\n        Q.when(request.body, function (body) {\n            var end, done;\n            if (body) {\n                done = body.forEach(function (chunk) {\n                    end = Q.when(end, function () {\n                        return Q.when(chunk, function (chunk) {\n                            _request.write(chunk, request.charset);\n                        });\n                    });\n                });\n            }\n            return Q.when(end, function () {\n                return Q.when(done, function () {\n                    _request.end();\n                });\n            });\n        });\n\n        return deferred.promise;\n    });\n};\n\n/**\n * Issues a GET request to the given URL and returns\n * a promise for a `String` containing the entirety\n * of the response.\n *\n * @param {String} url\n * @returns {Promise * String} or a rejection if the\n * status code is not exactly 200.  The reason for the\n * rejection is the full response object.\n */\nexports.read = function (request, qualifier) {\n    qualifier = qualifier || function (response) {\n        return response.status === 200;\n    };\n    return Q.when(exports.request(request), function (response) {\n        if (!qualifier(response)){\n            var error = new Error(\"HTTP request failed with code \" + response.status);\n            error.response = response;\n            throw error;\n        }\n        return Q.post(response.body, 'read', []);\n    });\n};\n\n\n/**\n * A wrapper for the Node HTTP Response as provided\n * by the Q HTTP Client API, suitable for use by the\n * Q HTTP Server API.\n */\nexports.ClientResponse = function (_response, charset) {\n    var response = Object.create(exports.ClientResponse.prototype);\n    /*** {Number} HTTP status code */\n    response.status = _response.statusCode;\n    /*** HTTP version */\n    response.version = _response.httpVersion;\n    /*** {Object} HTTP headers */\n    response.headers = _response.headers;\n    /***\n     * A Q IO asynchronous text reader.\n     */\n    response.node = _response;\n    response.nodeResponse = _response; // Deprecated\n    response.nodeConnection = _response.connection; // Deprecated\n    return Q.when(Reader(_response, charset), function (body) {\n        response.body = body;\n        return response;\n    });\n};","blocks":{"total":61,"seen":42,"missing":19,"percentage":0.6885245901639344}},"hash":"15471e3864d798bf82331cd2228a2716"},"/Users/kris/q-io/http-apps.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":150,"total":150,"coverage":{},"source":"/**\n * Provides tools for making, routing, adapting, and decorating\n * Q-JSGI web applications.\n *\n * Duck Types\n * ----------\n *\n * A Q-JSGI _app_ is a function that accepts a request and returns a\n * response.  The response may be promised.\n *\n * A Q-JSGI _request_ is an object or a promise for an object that has\n * the following properties:\n *\n * * `method` is the HTTP request method as a string.\n * * `path` is a string, guaranteed to start with `\"/\"`.\n * * `headers` is an object mapping lower-case HTTP headers to\n *   their corresponding values as strings.\n * * `body` is a Q-JSGI content body.\n *\n * A Q-JSGI _response_ is an object or a promise for an object that\n * has the following properties:\n *\n * * `status` is the HTTP response status code as a number.\n * * `headers` is an object mapping lower-case HTTP headers to their\n *   corresponding values as strings.\n * * `body` is a Q-JSGI content body.\n *\n * A Q-JSGI response and request content _body_ can be as simple as an\n * array of strings.  It can be a promise.  In general, it must be an\n * object that has a `forEach` method.  The `forEach` method accepts a\n * `write` function.  It goes without saying that `forEach` returns\n * `undefined`, but it can return a promise for `undefined` that will\n * resolve when it has made all of its `write` calls and the request\n * or response can be closed, re-used, or kept alive..  The `forEach`\n * function may call `write` with a `String` any number of times.  The\n * `String` may be promised.\n *\n * @module\n */\n\nrequire(\"collections/shim\");\nvar Q = require(\"q\");\nvar HTTP = require(\"./http\");\nvar FS = require(\"./fs\");\nvar URL = require(\"url2\");\nvar inspect = require(\"util\").inspect;\n\nexports.Chain = require(\"./http-apps/chain\");\n\nvar RouteApps = require(\"./http-apps/route\");\nexports.Cap = RouteApps.Cap;\nexports.Tap = RouteApps.Tap;\nexports.Trap = RouteApps.Trap;\nexports.Branch = RouteApps.Branch;\n\nvar ContentApps = require(\"./http-apps/content\");\nexports.Content = ContentApps.Content;\nexports.content = ContentApps.content;\nexports.ok = ContentApps.ok;\nexports.ContentRequest = ContentApps.ContentRequest;\nexports.Inspect = ContentApps.Inspect;\nexports.ParseQuery = ContentApps.ParseQuery;\n\nvar FsApps = require(\"./http-apps/fs\");\nexports.File = FsApps.File;\nexports.FileTree = FsApps.FileTree;\nexports.file = FsApps.file;\nexports.directory = FsApps.directory;\nexports.etag = FsApps.etag;\n\nexports.ListDirectories = FsApps.ListDirectories;\nexports.listDirectory = FsApps.listDirectory;\nexports.listDirectoryHtmlFragment = FsApps.listDirectoryHtmlFragment;\nexports.listDirectoryText = FsApps.listDirectoryText;\nexports.listDirectoryMarkdown = FsApps.listDirectoryMarkdown;\nexports.listDirectoryJson = FsApps.listDirectoryJson;\nexports.listDirectoryData = FsApps.listDirectoryData;\nexports.DirectoryIndex = FsApps.DirectoryIndex;\n\nvar HtmlApps = require(\"./http-apps/html\");\nexports.HandleHtmlFragmentResponses = HtmlApps.HandleHtmlFragmentResponses;\nexports.handleHtmlFragmentResponse = HtmlApps.handleHtmlFragmentResponse;\nexports.escapeHtml = HtmlApps.escapeHtml;\n\nvar JsonApps = require(\"./http-apps/json\");\nexports.HandleJsonResponses = JsonApps.HandleJsonResponses;\nexports.handleJsonResponse = JsonApps.handleJsonResponse;\nexports.Json = JsonApps.Json;\nexports.json = JsonApps.json;\nexports.JsonRequest = JsonApps.JsonRequest;\n\nvar RedirectApps = require(\"./http-apps/redirect\");\nexports.PermanentRedirect = RedirectApps.PermanentRedirect;\nexports.PermanentRedirectTree = RedirectApps.PermanentRedirectTree;\nexports.TemporaryRedirect = RedirectApps.TemporaryRedirect;\nexports.TemporaryRedirectTree = RedirectApps.TemporaryRedirectTree;\nexports.Redirect = RedirectApps.Redirect;\nexports.RedirectTree = RedirectApps.RedirectTree;\nexports.permanentRedirect = RedirectApps.permanentRedirect;\nexports.permanentRedirectTree = RedirectApps.permanentRedirectTree;\nexports.temporaryRedirect = RedirectApps.temporaryRedirect;\nexports.temporaryRedirectTree = RedirectApps.temporaryRedirectTree;\nexports.redirectTree = RedirectApps.redirectTree;\nexports.redirect = RedirectApps.redirect;\nexports.redirectText = RedirectApps.redirectText;\nexports.redirectHtml = RedirectApps.redirectHtml;\nexports.RedirectTrap = RedirectApps.RedirectTrap;\nexports.isRedirect = RedirectApps.isRedirect;\n\nvar ProxyApps = require(\"./http-apps/proxy\");\nexports.Proxy = ProxyApps.Proxy;\nexports.ProxyTree = ProxyApps.ProxyTree;\n\nvar NegotiationApps = require(\"./http-apps/negotiate\");\nexports.negotiate = NegotiationApps.negotiate;\nexports.Method = NegotiationApps.Method;\nexports.ContentType = NegotiationApps.ContentType;\nexports.Language = NegotiationApps.Language;\nexports.Charset = NegotiationApps.Charset;\nexports.Encoding = NegotiationApps.Encoding;\nexports.Host = NegotiationApps.Host;\nexports.Select = NegotiationApps.Select;\n\nvar StatusApps = require(\"./http-apps/status\");\nexports.statusCodes = StatusApps.statusCodes;\nexports.statusMessages = StatusApps.statusMessages;\nexports.statusWithNoEntityBody = StatusApps.statusWithNoEntityBody;\nexports.appForStatus = StatusApps.appForStatus;\nexports.responseForStatus = StatusApps.responseForStatus;\nexports.textResponseForStatus = StatusApps.textResponseForStatus;\nexports.htmlResponseForStatus = StatusApps.htmlResponseForStatus;\nexports.badRequest = StatusApps.badRequest;\nexports.notFound = StatusApps.notFound;\nexports.methodNotAllowed = StatusApps.methodNotAllowed;\nexports.noLanguage = StatusApps.noLanguage;\nexports.notAcceptable = StatusApps.notAcceptable;\n\nvar DecoratorApps = require(\"./http-apps/decorators\");\nexports.Normalize = DecoratorApps.Normalize;\nexports.Date = DecoratorApps.Date;\nexports.Error = DecoratorApps.Error;\nexports.Debug = DecoratorApps.Debug;\nexports.Log = DecoratorApps.Log;\nexports.Time = DecoratorApps.Time;\nexports.Headers = DecoratorApps.Headers;\nexports.Permanent = DecoratorApps.Permanent;\nexports.Decorators = DecoratorApps.Decorators;\n\nvar CookieApps = require(\"./http-apps/cookie\");\nexports.CookieJar = CookieApps.CookieJar;","blocks":{"total":0,"seen":0,"missing":0,"percentage":1}},"hash":"aab528a3d414d2619a1ece261b28b54c"},"/Users/kris/q-io/http-apps/chain.js":{"stats":{"percentage":0.9090909090909091,"lines":[{"lineno":11},{"lineno":16}],"missing":2,"seen":20,"total":22,"coverage":{"11":{"partial":false,"source":"    if (!App) throw new Error(\"App is not defined after \" + this.app);","missing":[{"startCol":14,"endCol":70},{"startCol":30,"endCol":68}]},"16":{"partial":true,"source":"            if (self.end !== Self && !next) throw new Error(\"App chain is broken after \" + App);","missing":[{"startCol":44,"endCol":96},{"startCol":60,"endCol":94}]}},"source":"module.exports = Chain;\nfunction Chain(end) {\n    var self = Object.create(Chain.prototype);\n    self.end = end || function (next) {\n        return next;\n    };\n    return self;\n};\n\nChain.prototype.use = function (App /*, ...args*/) {\n    if (!App) throw new Error(\"App is not defined after \" + this.app);\n    var args = Array.prototype.slice.call(arguments, 1);\n    var self = this;\n    this.end = (function (End) {\n        return function Self(next) {\n            if (self.end !== Self && !next) throw new Error(\"App chain is broken after \" + App);\n            return End(App.apply(null, [next].concat(args)));\n        };\n    })(this.end);\n    this.app = App;\n    return this;\n};","blocks":{"total":7,"seen":5,"missing":2,"percentage":0.7142857142857143}},"hash":"724d87dd904b80d19083c43efde28c67"},"/Users/kris/q-io/http-apps/route.js":{"stats":{"percentage":0.8780487804878049,"lines":[{"lineno":23},{"lineno":39},{"lineno":77},{"lineno":82},{"lineno":92},{"lineno":105},{"lineno":106},{"lineno":108},{"lineno":109},{"lineno":110},{"lineno":111},{"lineno":112},{"lineno":114},{"lineno":118},{"lineno":121}],"missing":15,"seen":108,"total":123,"coverage":{"23":{"partial":false,"source":"            return notFound(request, response);","missing":[{"startCol":12,"endCol":47},{"startCol":19,"endCol":46}]},"39":{"partial":false,"source":"                return response;","missing":[{"startCol":16,"endCol":32}]},"77":{"partial":false,"source":"        paths = {};","missing":[{"startCol":8,"endCol":19}]},"82":{"partial":false,"source":"            return notFound(request, response);","missing":[{"startCol":12,"endCol":47},{"startCol":19,"endCol":46}]},"92":{"partial":false,"source":"        return notFound(request, response);","missing":[{"startCol":8,"endCol":43},{"startCol":15,"endCol":42}]},"105":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"106":{"partial":false,"source":"        var i = 0, ii = cascade.length;","missing":[{},{"startCol":8,"endCol":39}]},"107":{"partial":false,"source":"        function next() {","missing":[{}]},"108":{"partial":false,"source":"            var response = cascade[i++](request, response);","missing":[{"startCol":12,"endCol":59},{"startCol":27,"endCol":58},{"startCol":35,"endCol":38},{}]},"109":{"partial":false,"source":"            if (i < ii) {","missing":[{"startCol":16,"endCol":22},{}]},"110":{"partial":false,"source":"                return Q.when(response, function (response) {","missing":[{}]},"111":{"partial":false,"source":"                    if (response.status === 404) {","missing":[{},{"startCol":24,"endCol":47}]},"112":{"partial":false,"source":"                        return next();","missing":[{},{"startCol":24,"endCol":38},{"startCol":31,"endCol":37}]},"113":{"partial":false,"source":"                    } else {","missing":[{}]},"114":{"partial":false,"source":"                        return response;","missing":[{},{"startCol":24,"endCol":40}]},"115":{"partial":false,"source":"                    }","missing":[{}]},"116":{"partial":false,"source":"                });","missing":[{}]},"117":{"partial":false,"source":"            } else {","missing":[{}]},"118":{"partial":false,"source":"                return response;","missing":[{"startCol":16,"endCol":32},{}]},"119":{"partial":false,"source":"            }","missing":[{}]},"120":{"partial":false,"source":"        }","missing":[{}]},"121":{"partial":false,"source":"        return next();","missing":[{},{"startCol":8,"endCol":22},{"startCol":15,"endCol":21}]},"122":{"partial":false,"source":"    };","missing":[{}]}},"source":"var Q = require(\"q\");\nvar StatusApps = require(\"./status\");\n\n/**\n * Makes a  Q-JSGI app that only responds when there is nothing left\n * on the path to route.  If the there is unprocessed data on the\n * path, the returned app either forwards to the `notFound` app or\n * returns a `404 Not Found` response.\n *\n * @param {App} app a Q-JSGI application to\n * respond to this end of the routing chain.\n * @param {App} notFound (optional) defaults\n * to the `notFound` app.\n * @returns {App}\n */\nexports.Cap = function (app, notFound) {\n    notFound = notFound || StatusApps.notFound;\n    return function (request, response) {\n        // TODO Distinguish these cases\n        if (request.pathInfo === \"\" || request.pathInfo === \"/\") {\n            return app(request, response);\n        } else {\n            return notFound(request, response);\n        }\n    };\n};\n\n/**\n * Wraps an app with a function that will observe incoming requests\n * before giving the app an opportunity to respond.  If the \"tap\"\n * function returns a response, it will be used in lieu of forwarding\n * the request to the wrapped app.\n */\nexports.Tap = function (app, tap) {\n    return function (request, response) {\n        var self = this, args = arguments;\n        return Q.when(tap.apply(this, arguments), function (response) {\n            if (response) {\n                return response;\n            } else {\n                return app.apply(self, args);\n            }\n        });\n    };\n};\n\n/**\n * Wraps an app with a \"trap\" function that intercepts and may\n * alter or replace the response of the wrapped application.\n */\nexports.Trap = function (app, trap) {\n    return function (request, response) {\n        return Q.when(app.apply(this, arguments), function (response) {\n            if (response) {\n                response.headers = response.headers || {};\n                return trap(response, request) || response;\n            }\n        });\n    };\n};\n\n/**\n * Makes a Q-JSGI app that branches requests based on the next\n * unprocessed path component.\n * @param {Object * App} paths a mapping from path components (single\n * file or directory names) to Q-JSGI applications for subsequent\n * routing.  The mapping may be a plain JavaScript `Object` record,\n * which must own the mapping properties, or an object that has\n * `has(key)` and `get(key)` methods in its prototype chain.\n * @param {App} notFound a Q-JSGI application\n * that handles requests for which the next file name does not exist\n * in paths.\n * @returns {App}\n */\nexports.Branch = function (paths, notFound) {\n    if (!paths)\n        paths = {};\n    if (!notFound)\n        notFound = StatusApps.notFound;\n    return function (request, response) {\n        if (!/^\\//.test(request.pathInfo)) {\n            return notFound(request, response);\n        }\n        var path = request.pathInfo.slice(1);\n        var parts = path.split(\"/\");\n        var part = decodeURIComponent(parts.shift());\n        if (Object.has(paths, part)) {\n            request.scriptName = request.scriptName + part + \"/\";\n            request.pathInfo = path.slice(part.length);\n            return Object.get(paths, part)(request, response);\n        }\n        return notFound(request, response);\n    };\n};\n\n/**\n * Returns the response of the first application that returns a\n * non-404 response status.\n *\n * @param {Array * App} apps a cascade of applications to try\n * successively until one of them returns a non-404 status.\n * @returns {App}\n */\nexports.FirstFound = function (cascade) {\n    return function (request, response) {\n        var i = 0, ii = cascade.length;\n        function next() {\n            var response = cascade[i++](request, response);\n            if (i < ii) {\n                return Q.when(response, function (response) {\n                    if (response.status === 404) {\n                        return next();\n                    } else {\n                        return response;\n                    }\n                });\n            } else {\n                return response;\n            }\n        }\n        return next();\n    };\n};","blocks":{"total":27,"seen":15,"missing":12,"percentage":0.5555555555555556}},"hash":"8932f49178abb8a03d5acd385d1b2cfc"},"/Users/kris/q-io/http-apps/status.js":{"stats":{"percentage":0.9710982658959537,"lines":[{"lineno":100},{"lineno":111},{"lineno":147},{"lineno":148},{"lineno":150}],"missing":5,"seen":168,"total":173,"coverage":{"100":{"partial":false,"source":"        throw \"Unknown status code\";","missing":[{"startCol":8,"endCol":36}]},"111":{"partial":false,"source":"        return {status: status, headers: {}};","missing":[{"startCol":8,"endCol":45}]},"147":{"partial":false,"source":"                write(\"<h1>\" + HtmlApps.escapeHtml(message) + \"</h1>\\n\");","missing":[{"startCol":16,"endCol":72},{"startCol":22,"endCol":59},{"startCol":31,"endCol":59}]},"148":{"partial":false,"source":"                write(\"<p>Status: \" + status + \"</p>\\n\");","missing":[{"startCol":16,"endCol":56},{"startCol":22,"endCol":44}]},"150":{"partial":false,"source":"                    write(\"<pre>\" + HtmlApps.escapeHtml(addendum) + \"</pre>\\n\");","missing":[{"startCol":20,"endCol":79},{"startCol":26,"endCol":65},{"startCol":36,"endCol":65}]}},"source":"var Negotiation = require(\"./negotiate\");\nvar HtmlApps = require(\"./html\");\n\n/**\n * {Object * String} a mapping of HTTP status codes to\n * their standard descriptions.\n */\n// Every standard HTTP code mapped to the appropriate message.\n// Stolen from Rack which stole from Mongrel\nexports.statusCodes = {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    102: 'Processing',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    207: 'Multi-Status',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Request Entity Too Large',\n    414: 'Request-URI Too Large',\n    415: 'Unsupported Media Type',\n    416: 'Request Range Not Satisfiable',\n    417: 'Expectation Failed',\n    422: 'Unprocessable Entity',\n    423: 'Locked',\n    424: 'Failed Dependency',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported',\n    507: 'Insufficient Storage'\n};\n\n/**\n * {Object * Number} a mapping from HTTP status descriptions\n * to HTTP status codes.\n */\nexports.statusMessages = {};\nfor (var code in exports.statusCodes)\n    exports.statusMessages[exports.statusCodes[code]] = +code;\n\n/**\n * Determines whether an HTTP response should have a\n * response body, based on its status code.\n * @param {Number} status\n * @returns whether the HTTP response for the given status\n * code has content.\n */\nexports.statusWithNoEntityBody = function (status) {\n    return (status >= 100 && status <= 199) ||\n        status == 204 || status == 304;\n};\n\n/**\n * @param {Number} status\n * @returns {Function(Request) :Response} a JSGI app that returns\n * a plain text response with the given status code.\n */\nexports.appForStatus = function (status) {\n    return function (request) {\n        return exports.responseForStatus(request, status, request.method + \" \" + request.path);\n    };\n};\n\n/**\n * @param {Number} status an HTTP status code\n * @param {String} message (optional) a message to include\n * in the response body.\n * @returns a JSGI HTTP response object with the given status\n * code and message as its body, if the status supports\n * a body.\n */\nexports.responseForStatus = function(request, status, addendum) {\n    if (exports.statusCodes[status] === undefined)\n        throw \"Unknown status code\";\n\n    var message = exports.statusCodes[status];\n\n    // RFC 2616, 10.2.5:\n    // The 204 response MUST NOT include a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.3.5:\n    // The 304 response MUST NOT contain a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    if (exports.statusWithNoEntityBody(status)) {\n        return {status: status, headers: {}};\n    } else {\n        var handlers = {};\n        handlers[\"text/plain\"] = exports.textResponseForStatus;\n        if (request.handleHtmlFragmentResponse) {\n            handlers[\"text/html\"] = exports.htmlResponseForStatus;\n        }\n        var responseForStatus = Negotiation.negotiate(request, handlers) || exports.textResponseForStatus;\n        return responseForStatus(request, status, message, addendum);\n    }\n};\n\nexports.textResponseForStatus = function (request, status, message, addendum) {\n    var content = message + \"\\n\";\n    if (addendum) {\n        content += addendum + \"\\n\";\n    }\n    var contentLength = content.length;\n    return {\n        status: status,\n        statusMessage: message,\n        headers: {\n            \"content-length\": contentLength\n        },\n        body: [content]\n    };\n};\n\nexports.htmlResponseForStatus = function (request, status, message, addendum) {\n    return {\n        status: status,\n        statusMessage: message,\n        headers: {},\n        htmlTitle: message,\n        htmlFragment: {\n            forEach: function (write) {\n                write(\"<h1>\" + HtmlApps.escapeHtml(message) + \"</h1>\\n\");\n                write(\"<p>Status: \" + status + \"</p>\\n\");\n                if (addendum) {\n                    write(\"<pre>\" + HtmlApps.escapeHtml(addendum) + \"</pre>\\n\");\n                }\n            }\n        }\n    }\n};\n\n/**\n * {App} an application that returns a 400 response.\n */\nexports.badRequest = exports.appForStatus(400);\n/**\n * {App} an application that returns a 404 response.\n */\nexports.notFound = exports.appForStatus(404);\n/**\n * {App} an application that returns a 405 response.\n */\nexports.methodNotAllowed = exports.appForStatus(405);\n/**\n * {App} an application that returns a 405 response.\n */\nexports.noLanguage =\nexports.notAcceptable = exports.appForStatus(406);","blocks":{"total":14,"seen":10,"missing":4,"percentage":0.7142857142857143}},"hash":"4204b9ad0dc749c7e27ca4fcd0763009"},"/Users/kris/q-io/http-apps/negotiate.js":{"stats":{"percentage":0.6888888888888889,"lines":[{"lineno":19},{"lineno":21},{"lineno":22},{"lineno":23},{"lineno":24},{"lineno":25},{"lineno":27},{"lineno":34},{"lineno":36},{"lineno":37},{"lineno":38},{"lineno":39},{"lineno":40},{"lineno":42},{"lineno":43},{"lineno":44},{"lineno":45},{"lineno":46},{"lineno":47},{"lineno":49},{"lineno":51},{"lineno":54},{"lineno":56},{"lineno":59},{"lineno":80},{"lineno":85},{"lineno":86},{"lineno":87}],"missing":28,"seen":62,"total":90,"coverage":{"19":{"partial":false,"source":"    var keys = Object.keys(methods);","missing":[{"startCol":4,"endCol":36},{"startCol":15,"endCol":35}]},"21":{"partial":false,"source":"        methodNotAllowed = exports.methodNotAllowed;","missing":[{"startCol":8,"endCol":52}]},"22":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"23":{"partial":false,"source":"        var method = request.method;","missing":[{"startCol":8,"endCol":36},{}]},"24":{"partial":false,"source":"        if (Object.has(keys, method)) {","missing":[{},{"startCol":12,"endCol":36}]},"25":{"partial":false,"source":"            return Object.get(methods, method)(request, response);","missing":[{},{"startCol":12,"endCol":66},{"startCol":19,"endCol":65},{"startCol":29,"endCol":46}]},"26":{"partial":false,"source":"        } else {","missing":[{}]},"27":{"partial":false,"source":"            return methodNotAllowed(request, response);","missing":[{"startCol":12,"endCol":55},{},{"startCol":19,"endCol":54}]},"28":{"partial":false,"source":"        }","missing":[{}]},"29":{"partial":false,"source":"    };","missing":[{}]},"34":{"partial":false,"source":"        var keys = Object.keys(types);","missing":[{"startCol":8,"endCol":38},{"startCol":19,"endCol":37}]},"36":{"partial":false,"source":"            notAcceptable = exports.notAcceptable;","missing":[{"startCol":12,"endCol":50}]},"37":{"partial":false,"source":"        return function (request, response) {","missing":[{}]},"38":{"partial":false,"source":"            var header = requestHeader;","missing":[{},{"startCol":12,"endCol":39}]},"39":{"partial":false,"source":"            if (typeof header === \"function\") {","missing":[{},{"startCol":16,"endCol":44}]},"40":{"partial":false,"source":"                header = requestHeader(request);","missing":[{},{"startCol":16,"endCol":48},{"startCol":25,"endCol":47}]},"41":{"partial":false,"source":"            }","missing":[{}]},"42":{"partial":false,"source":"            var accept = request.headers[requestHeader] || \"*\";","missing":[{"startCol":25,"endCol":62},{},{"startCol":12,"endCol":63}]},"43":{"partial":false,"source":"            var type = MimeParse.bestMatch(keys, accept);","missing":[{},{"startCol":12,"endCol":57},{"startCol":23,"endCol":56}]},"44":{"partial":false,"source":"            request.terms = request.terms || {};","missing":[{},{"startCol":12,"endCol":48},{"startCol":28,"endCol":47}]},"45":{"partial":false,"source":"            request.terms[responseHeader] = type;","missing":[{},{"startCol":12,"endCol":49}]},"46":{"partial":false,"source":"            if (Object.has(keys, type)) {","missing":[{},{"startCol":16,"endCol":38}]},"47":{"partial":false,"source":"                return Q.when(types[type](request, response), function (response) {","missing":[{"startCol":30,"endCol":60},{}]},"48":{"partial":false,"source":"                    if (","missing":[{}]},"49":{"partial":false,"source":"                        respond !== null &&","missing":[{},{"startCol":24,"endCol":40}]},"50":{"partial":false,"source":"                        response &&","missing":[{}]},"51":{"partial":false,"source":"                        response.status === 200 &&","missing":[{},{"startCol":24,"endCol":47}]},"52":{"partial":false,"source":"                        response.headers","missing":[{}]},"53":{"partial":false,"source":"                    ) {","missing":[{}]},"54":{"partial":false,"source":"                        response.headers[responseHeader] = type;","missing":[{},{"startCol":24,"endCol":64}]},"55":{"partial":false,"source":"                    }","missing":[{}]},"56":{"partial":false,"source":"                    return response;","missing":[{},{"startCol":20,"endCol":36}]},"57":{"partial":false,"source":"                });","missing":[{}]},"58":{"partial":false,"source":"            } else {","missing":[{}]},"59":{"partial":false,"source":"                return notAcceptable(request, response);","missing":[{"startCol":23,"endCol":55},{},{"startCol":16,"endCol":56}]},"60":{"partial":false,"source":"            }","missing":[{}]},"61":{"partial":false,"source":"        };","missing":[{}]},"80":{"partial":false,"source":"    return (request.headers.host || \"*\") + \":\" + request.port;","missing":[{"startCol":4,"endCol":62},{"startCol":11,"endCol":40}]},"85":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"86":{"partial":false,"source":"        return Q.when(select(request, response), function (app) {","missing":[{},{"startCol":22,"endCol":47}]},"87":{"partial":false,"source":"            return app(request, response);","missing":[{},{"startCol":12,"endCol":42},{"startCol":19,"endCol":41}]},"88":{"partial":false,"source":"        });","missing":[{}]},"89":{"partial":false,"source":"    };","missing":[{}]}},"source":"var Q = require(\"q\");\nvar MimeParse = require(\"mimeparse\");\n\nexports.negotiate = negotiate;\nfunction negotiate(request, types, header) {\n    var keys = Object.keys(types);\n    var accept = request.headers[header || \"accept\"] || \"*\";\n    var best = MimeParse.bestMatch(keys, accept);\n    return types[best];\n}\n\n/// branch on HTTP method\n/**\n * @param {Object * App} methods\n * @param {App} notAllowed (optional)\n * @returns {App}\n */\nexports.Method = function (methods, methodNotAllowed) {\n    var keys = Object.keys(methods);\n    if (!methodNotAllowed)\n        methodNotAllowed = exports.methodNotAllowed;\n    return function (request, response) {\n        var method = request.method;\n        if (Object.has(keys, method)) {\n            return Object.get(methods, method)(request, response);\n        } else {\n            return methodNotAllowed(request, response);\n        }\n    };\n};\n\nvar Negotiator = function (requestHeader, responseHeader, respond) {\n    return function (types, notAcceptable) {\n        var keys = Object.keys(types);\n        if (!notAcceptable)\n            notAcceptable = exports.notAcceptable;\n        return function (request, response) {\n            var header = requestHeader;\n            if (typeof header === \"function\") {\n                header = requestHeader(request);\n            }\n            var accept = request.headers[requestHeader] || \"*\";\n            var type = MimeParse.bestMatch(keys, accept);\n            request.terms = request.terms || {};\n            request.terms[responseHeader] = type;\n            if (Object.has(keys, type)) {\n                return Q.when(types[type](request, response), function (response) {\n                    if (\n                        respond !== null &&\n                        response &&\n                        response.status === 200 &&\n                        response.headers\n                    ) {\n                        response.headers[responseHeader] = type;\n                    }\n                    return response;\n                });\n            } else {\n                return notAcceptable(request, response);\n            }\n        };\n    };\n};\n\n/// branch on HTTP content negotiation\n/**\n * Routes based on content negotiation, between the request's `accept`\n * header and the application's list of possible content types.\n *\n * @param {Object * App} types mapping content types to apps that can\n * handle them.\n * @param {App} notAcceptable\n * @returns {App}\n */\nexports.ContentType = Negotiator(\"accept\", \"content-type\");\nexports.Language = Negotiator(\"accept-language\", \"language\");\nexports.Charset = Negotiator(\"accept-charset\", \"charset\");\nexports.Encoding = Negotiator(\"accept-encoding\", \"encoding\");\nexports.Host = Negotiator(function (request) {\n    return (request.headers.host || \"*\") + \":\" + request.port;\n}, \"host\", null);\n\n// Branch on a selector function based on the request\nexports.Select = function (select) {\n    return function (request, response) {\n        return Q.when(select(request, response), function (app) {\n            return app(request, response);\n        });\n    };\n};","blocks":{"total":19,"seen":2,"missing":17,"percentage":0.10526315789473684}},"hash":"323f75230e2749e54b7da35d560d5db7"},"/Users/kris/q-io/http-apps/html.js":{"stats":{"percentage":0.9821428571428571,"lines":[{"lineno":19}],"missing":1,"seen":55,"total":56,"coverage":{"19":{"partial":false,"source":"                return response;","missing":[{"startCol":16,"endCol":32}]}},"source":"var Q = require(\"q\");\n// TODO negotiate text/html vs text/html+fragment (or other mime type)\n\n/**\n * @param {Request} request\n * @param {String} path\n * @param {String} contentType\n * @returns {Response}\n */\nexports.HandleHtmlFragmentResponses = function (app, handleHtmlFragmentResponse) {\n    handleHtmlFragmentResponse = handleHtmlFragmentResponse || exports.handleHtmlFragmentResponse;\n    return function (request) {\n        request.handleHtmlFragmentResponse = handleHtmlFragmentResponse;\n        return Q.fcall(app, request)\n        .then(function (response) {\n            if (response.htmlFragment) {\n                return Q.fcall(handleHtmlFragmentResponse, response);\n            } else {\n                return response;\n            }\n        });\n    };\n};\n\nexports.handleHtmlFragmentResponse = function (response) {\n    var htmlFragment = response.htmlFragment;\n    delete response.htmlFragment;\n    response.headers[\"content-type\"] = \"text/html; charset=utf-8\";\n    response.body = {\n        forEach: function (write) {\n            write(\"<!doctype html>\\n\");\n            write(\"<html>\\n\");\n            write(\"    <head>\\n\");\n            if (response.htmlTitle !== void 0) {\n                write(\"        <title>\" + escapeHtml(response.htmlTitle) + \"</title>\\n\");\n            }\n            write(\"    </head>\\n\");\n            write(\"    <body>\\n\");\n            htmlFragment.forEach(function (line) {\n                write(\"        \" + line);\n            });\n            write(\"    </body>\\n\");\n            write(\"</html>\\n\");\n        }\n    };\n    return response;\n};\n\nexports.escapeHtml = escapeHtml;\nfunction escapeHtml(text) {\n    return String(text)\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n}","blocks":{"total":10,"seen":9,"missing":1,"percentage":0.9}},"hash":"a15d13c2a05574386d56e72864370939"},"/Users/kris/q-io/http-apps/content.js":{"stats":{"percentage":0.8241758241758241,"lines":[{"lineno":35},{"lineno":36},{"lineno":37},{"lineno":38},{"lineno":40},{"lineno":41},{"lineno":59},{"lineno":60},{"lineno":61},{"lineno":71},{"lineno":72},{"lineno":73},{"lineno":78},{"lineno":87},{"lineno":88},{"lineno":89}],"missing":16,"seen":75,"total":91,"coverage":{"35":{"partial":false,"source":"    status = status || 200;","missing":[{"startCol":4,"endCol":27},{"startCol":13,"endCol":26}]},"36":{"partial":false,"source":"    content = content || \"\";","missing":[{"startCol":4,"endCol":28},{"startCol":14,"endCol":27}]},"37":{"partial":false,"source":"    if (typeof content === \"string\") {","missing":[{"startCol":8,"endCol":35}]},"38":{"partial":false,"source":"        content = [content];","missing":[{"startCol":8,"endCol":28}]},"40":{"partial":false,"source":"    contentType = contentType || \"text/plain\";","missing":[{"startCol":4,"endCol":46},{"startCol":18,"endCol":45}]},"41":{"partial":false,"source":"    return {","missing":[{}]},"42":{"partial":false,"source":"        \"status\": status,","missing":[{}]},"43":{"partial":false,"source":"        \"headers\": {","missing":[{}]},"44":{"partial":false,"source":"            \"content-type\": contentType","missing":[{}]},"45":{"partial":false,"source":"        },","missing":[{}]},"46":{"partial":false,"source":"        \"body\": content","missing":[{}]},"47":{"partial":false,"source":"    };","missing":[{}]},"59":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"60":{"partial":false,"source":"        return Q.when(request.body.read(), function (body) {","missing":[{},{"startCol":22,"endCol":41}]},"61":{"partial":false,"source":"            return app(body, request, response);","missing":[{},{"startCol":12,"endCol":48},{"startCol":19,"endCol":47}]},"62":{"partial":false,"source":"        });","missing":[{}]},"63":{"partial":false,"source":"    };","missing":[{}]},"71":{"partial":false,"source":"    return Negotiate.Method({\"GET\": function (request, response) {","missing":[{}]},"72":{"partial":false,"source":"        return Q.when(app(request, response), function (object) {","missing":[{},{"startCol":22,"endCol":44}]},"73":{"partial":false,"source":"            return {","missing":[{}]},"74":{"partial":false,"source":"                status: 200,","missing":[{}]},"75":{"partial":false,"source":"                headers: {","missing":[{}]},"76":{"partial":false,"source":"                    \"content-type\": \"text/plain\"","missing":[{}]},"77":{"partial":false,"source":"                },","missing":[{}]},"78":{"partial":false,"source":"                body: [inspect(object)]","missing":[{},{"startCol":23,"endCol":38}]},"79":{"partial":false,"source":"            }","missing":[{}]},"80":{"partial":false,"source":"        });","missing":[{}]},"81":{"partial":false,"source":"    }});","missing":[{}]},"87":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"88":{"partial":false,"source":"        request.query = QS.parse(URL.parse(request.url).query || \"\");","missing":[{"startCol":8,"endCol":69},{},{"startCol":24,"endCol":68},{"startCol":33,"endCol":67},{"startCol":42,"endCol":55}]},"89":{"partial":false,"source":"        return app(request, response);","missing":[{"startCol":8,"endCol":38},{"startCol":15,"endCol":37},{}]},"90":{"partial":false,"source":"    };","missing":[{}]}},"source":"var Negotiate = require(\"./negotiate\");\nvar QS = require(\"qs\");\nvar URL = require(\"url2\");\n\n/**\n * Makes an app that returns a response with static content\n * from memory.\n * @param {Body} body a Q-JSGI\n * response body\n * @param {String} contentType\n * @param {Number} status\n * @returns {App} a Q-JSGI app\n */\nexports.Content = function (body, contentType, status) {\n    return function (request, response) {\n        return {\n            \"status\": status || 200,\n            \"headers\": {\n                \"content-type\": contentType || \"text/plain\"\n            },\n            \"body\": body || \"\"\n        };\n    };\n};\n\n/**\n * Returns a Q-JSGI response with the given content.\n * @param {Body} content (optional) defaults to `[\"\"]`\n * @param {String} contentType (optional) defaults to `\"text/plain\"`\n * @param {Number} status (optional) defaults to `200`\n * @returns {Response}\n */\nexports.content =\nexports.ok = function (content, contentType, status) {\n    status = status || 200;\n    content = content || \"\";\n    if (typeof content === \"string\") {\n        content = [content];\n    }\n    contentType = contentType || \"text/plain\";\n    return {\n        \"status\": status,\n        \"headers\": {\n            \"content-type\": contentType\n        },\n        \"body\": content\n    };\n};\n\n/**\n * Wraps an app such that it expects to receive content\n * in the request body and passes that content as a string\n * to as the second argument to the wrapped JSGI app.\n *\n * @param {Function(Request, Object):Response} app\n * @returns {App}\n */\nexports.ContentRequest = function (app) {\n    return function (request, response) {\n        return Q.when(request.body.read(), function (body) {\n            return app(body, request, response);\n        });\n    };\n};\n\n/**\n * @param {Function(Request):Object}\n * @returns {App}\n */\nexports.Inspect = function (app) {\n    return Negotiate.Method({\"GET\": function (request, response) {\n        return Q.when(app(request, response), function (object) {\n            return {\n                status: 200,\n                headers: {\n                    \"content-type\": \"text/plain\"\n                },\n                body: [inspect(object)]\n            }\n        });\n    }});\n};\n\n/**\n */\nexports.ParseQuery = function (app) {\n    return function (request, response) {\n        request.query = QS.parse(URL.parse(request.url).query || \"\");\n        return app(request, response);\n    };\n};","blocks":{"total":12,"seen":2,"missing":10,"percentage":0.16666666666666666}},"hash":"9fa58444f351b2772495236784050d98"},"/Users/kris/q-io/http-apps/fs.js":{"stats":{"percentage":0.8814814814814815,"lines":[{"lineno":48},{"lineno":55},{"lineno":57},{"lineno":62},{"lineno":66},{"lineno":70},{"lineno":97},{"lineno":106},{"lineno":123},{"lineno":124},{"lineno":125},{"lineno":145},{"lineno":147},{"lineno":168},{"lineno":211},{"lineno":219},{"lineno":229},{"lineno":238},{"lineno":241},{"lineno":298},{"lineno":300},{"lineno":307},{"lineno":308},{"lineno":309},{"lineno":310},{"lineno":311},{"lineno":312},{"lineno":314},{"lineno":316},{"lineno":324},{"lineno":326},{"lineno":336},{"lineno":372},{"lineno":373},{"lineno":374},{"lineno":375},{"lineno":378},{"lineno":379},{"lineno":381},{"lineno":383},{"lineno":385},{"lineno":387},{"lineno":388},{"lineno":391},{"lineno":392},{"lineno":393},{"lineno":395},{"lineno":400}],"missing":48,"seen":357,"total":405,"coverage":{"48":{"partial":false,"source":"            RedirectApps.permanentRedirect :","missing":[{"startCol":12,"endCol":42}]},"55":{"partial":false,"source":"                    return options.notFound(request, response);","missing":[{"startCol":20,"endCol":63},{"startCol":27,"endCol":62}]},"57":{"partial":false,"source":"                    return redirect(request, fs.relativeFromFile(path, canonical));","missing":[{"startCol":20,"endCol":83},{"startCol":27,"endCol":82},{"startCol":45,"endCol":81}]},"62":{"partial":false,"source":"                        return options.file(request, canonical, options.contentType, fs);","missing":[{"startCol":24,"endCol":89},{"startCol":31,"endCol":88}]},"66":{"partial":false,"source":"                        return options.notFound(request, response);","missing":[{"startCol":24,"endCol":67},{"startCol":31,"endCol":66}]},"70":{"partial":false,"source":"                return options.notFound(request, response);","missing":[{"startCol":16,"endCol":59},{"startCol":23,"endCol":58}]},"97":{"partial":false,"source":"                etag != request.headers[\"if-range\"]","missing":[{"startCol":16,"endCol":51}]},"106":{"partial":false,"source":"                        return StatusApps.responseForStatus(request, 416); // not satisfiable","missing":[{"startCol":24,"endCol":74},{"startCol":31,"endCol":73}]},"123":{"partial":false,"source":"            if (etag == request.headers[\"if-none-match\"])","missing":[{"startCol":16,"endCol":56}]},"124":{"partial":false,"source":"                return StatusApps.responseForStatus(request, 304);","missing":[{"startCol":16,"endCol":66},{"startCol":23,"endCol":65}]},"125":{"partial":false,"source":"            headers[\"content-length\"] = \"\" + stat.size;","missing":[{"startCol":12,"endCol":55},{"startCol":40,"endCol":54}]},"145":{"partial":false,"source":"        return;","missing":[{"startCol":8,"endCol":15}]},"147":{"partial":false,"source":"        return;","missing":[{"startCol":8,"endCol":15}]},"168":{"partial":false,"source":"        return;","missing":[{"startCol":8,"endCol":15}]},"211":{"partial":false,"source":"            throw new Error(\"DirectoryIndex must be used after ListDirectories\");","missing":[{"startCol":12,"endCol":81}]},"219":{"partial":false,"source":"                return response;","missing":[{"startCol":16,"endCol":32}]},"229":{"partial":false,"source":"        return RedirectApps.redirect(request, request.location.file + \"/\");","missing":[{"startCol":8,"endCol":75},{"startCol":15,"endCol":74},{"startCol":46,"endCol":73}]},"238":{"partial":false,"source":"        handlers[\"application/json\"] = exports.listDirectoryJson;","missing":[{"startCol":8,"endCol":65}]},"241":{"partial":false,"source":"        return response;","missing":[{"startCol":8,"endCol":24}]},"298":{"partial":false,"source":"    return exports.listDirectoryData(request, response)","missing":[{"startCol":36,"endCol":55},{}]},"299":{"partial":false,"source":"    .then(function (data) {","missing":[{}]},"300":{"partial":false,"source":"        return {","missing":[{}]},"301":{"partial":false,"source":"            status: 200,","missing":[{}]},"302":{"partial":false,"source":"            headers: {","missing":[{}]},"303":{"partial":false,"source":"                \"content-type\": \"text/plain\"","missing":[{}]},"304":{"partial":false,"source":"            },","missing":[{}]},"305":{"partial":false,"source":"            body: {","missing":[{}]},"306":{"partial":false,"source":"                forEach: function (write) {","missing":[{}]},"307":{"partial":false,"source":"                    write(\"\\n# Directory Index\\n\\n\");","missing":[{"startCol":20,"endCol":53},{}]},"308":{"partial":false,"source":"                    Object.keys(data).forEach(function (name) {","missing":[{},{"startCol":31,"endCol":37}]},"309":{"partial":false,"source":"                        var stat = data[name];","missing":[{"startCol":24,"endCol":46},{}]},"310":{"partial":false,"source":"                        var suffix = \"\";","missing":[{},{"startCol":24,"endCol":40}]},"311":{"partial":false,"source":"                        if (stat.type === \"directory\") {","missing":[{},{"startCol":28,"endCol":53}]},"312":{"partial":false,"source":"                            suffix = \"/\";","missing":[{},{"startCol":28,"endCol":41}]},"313":{"partial":false,"source":"                        }","missing":[{}]},"314":{"partial":false,"source":"                        write(\"-   \" + name + suffix + \"\\n\");","missing":[{},{"startCol":24,"endCol":60},{"startCol":30,"endCol":43}]},"315":{"partial":false,"source":"                    });","missing":[{}]},"316":{"partial":false,"source":"                    write(\"\\n\");","missing":[{"startCol":20,"endCol":32},{}]},"317":{"partial":false,"source":"                }","missing":[{}]},"318":{"partial":false,"source":"            }","missing":[{}]},"319":{"partial":false,"source":"        };","missing":[{}]},"320":{"partial":false,"source":"    });","missing":[{}]},"324":{"partial":false,"source":"    return exports.listDirectoryData(request, response)","missing":[{},{"startCol":36,"endCol":55}]},"325":{"partial":false,"source":"    .then(function (data) {","missing":[{}]},"326":{"partial":false,"source":"        return {","missing":[{}]},"327":{"partial":false,"source":"            status: 200,","missing":[{}]},"328":{"partial":false,"source":"            headers: {},","missing":[{}]},"329":{"partial":false,"source":"            data: data","missing":[{}]},"330":{"partial":false,"source":"        };","missing":[{}]},"331":{"partial":false,"source":"    });","missing":[{}]},"336":{"partial":false,"source":"        throw new Error(\"Can't list a directory without a designated file system\");","missing":[{"startCol":8,"endCol":83}]},"372":{"partial":false,"source":"    indexFile = indexFile || \"index.html\";","missing":[{"startCol":4,"endCol":42},{"startCol":16,"endCol":41}]},"373":{"partial":false,"source":"    return function (request) {","missing":[{}]},"374":{"partial":false,"source":"        request.directoryIndex = true;","missing":[{"startCol":8,"endCol":38},{}]},"375":{"partial":false,"source":"        request.location = URL.parse(request.path);","missing":[{"startCol":8,"endCol":51},{"startCol":27,"endCol":50},{}]},"376":{"partial":false,"source":"        // redirect index.html to containing directory","missing":[{}]},"377":{"partial":false,"source":"        // TODO worry about whether this file actually exists","missing":[{}]},"378":{"partial":false,"source":"        if (request.location.file === indexFile) {","missing":[{"startCol":12,"endCol":47},{}]},"379":{"partial":false,"source":"            return RedirectApps.redirect(request, \".\");","missing":[{"startCol":12,"endCol":55},{"startCol":19,"endCol":54},{}]},"380":{"partial":false,"source":"        } else {","missing":[{}]},"381":{"partial":false,"source":"            return Q.fcall(app, request)","missing":[{"startCol":26,"endCol":40},{}]},"382":{"partial":false,"source":"            .then(function (response) {","missing":[{}]},"383":{"partial":false,"source":"                if (response.directory !== void 0) {","missing":[{},{"startCol":20,"endCol":49}]},"384":{"partial":false,"source":"                    if (request.location.file) {","missing":[{}]},"385":{"partial":false,"source":"                        return RedirectApps.redirect(request, request.location.file + \"/\");","missing":[{"startCol":24,"endCol":91},{"startCol":31,"endCol":90},{},{"startCol":62,"endCol":89}]},"386":{"partial":false,"source":"                    } else {","missing":[{}]},"387":{"partial":false,"source":"                        var index = request.fs.join(response.directory, indexFile);","missing":[{},{"startCol":24,"endCol":83},{"startCol":36,"endCol":82}]},"388":{"partial":false,"source":"                        return Q.invoke(request.fs, \"isFile\", index)","missing":[{},{"startCol":39,"endCol":68}]},"389":{"partial":false,"source":"                        .then(function (isFile) {","missing":[{}]},"390":{"partial":false,"source":"                            if (isFile) {","missing":[{}]},"391":{"partial":false,"source":"                                request.url = URL.resolve(request.url, indexFile);","missing":[{},{"startCol":32,"endCol":82},{"startCol":46,"endCol":81}]},"392":{"partial":false,"source":"                                request.pathInfo += indexFile;","missing":[{},{"startCol":32,"endCol":62}]},"393":{"partial":false,"source":"                                return app(request);","missing":[{},{"startCol":32,"endCol":52},{"startCol":39,"endCol":51}]},"394":{"partial":false,"source":"                            } else {","missing":[{}]},"395":{"partial":false,"source":"                                return response;","missing":[{},{"startCol":32,"endCol":48}]},"396":{"partial":false,"source":"                            }","missing":[{}]},"397":{"partial":false,"source":"                        });","missing":[{}]},"398":{"partial":false,"source":"                    }","missing":[{}]},"399":{"partial":false,"source":"                } else {","missing":[{}]},"400":{"partial":false,"source":"                    return response;","missing":[{},{"startCol":20,"endCol":36}]},"401":{"partial":false,"source":"                }","missing":[{}]},"402":{"partial":false,"source":"            });","missing":[{}]},"403":{"partial":false,"source":"        }","missing":[{}]},"404":{"partial":false,"source":"    };","missing":[{}]}},"source":"var Q = require(\"q\");\nvar URL = require(\"url2\");\nvar MimeTypes = require(\"mime\");\nvar FS = require(\"../fs\");\nvar StatusApps = require(\"./status\");\nvar RedirectApps = require(\"./redirect\");\nvar Negotiation = require(\"./negotiate\");\nvar HtmlApps = require(\"./html\");\n\n/**\n * @param {String} path\n * @param {String} contentType\n * @returns {App}\n */\nexports.File = function (path, contentType) {\n    return function (request, response) {\n        return exports.file(request, String(path), contentType);\n    };\n};\n\n/**\n * @param {String} path\n * @param {{\n       notFound,\n       file,\n       directory,\n       contentType,\n       redirectSymbolicLinks:Boolean,\n       redirect:Function(location),\n       permanent:Boolean\n * }} options\n * @returns {App}\n */\nexports.FileTree = function (root, options) {\n    if (!options)\n        options = {};\n    options.notFound = options.notFound || StatusApps.notFound;\n    options.file = options.file || exports.file;\n    options.directory = options.directory || exports.directory;\n    options.fs = options.fs || FS;\n    var fs = options.fs;\n    root = fs.canonical(root);\n    return function (request, response) {\n        var location = URL.parse(request.url);\n        request.fs = fs;\n        var redirect = options.redirect || (\n            request.permanent || options.permanent ?\n            RedirectApps.permanentRedirect :\n            RedirectApps.temporaryRedirect\n        );\n        return Q.when(root, function (root) {\n            var path = fs.join(root, request.pathInfo.slice(1));\n            return Q.when(fs.canonical(path), function (canonical) {\n                if (!fs.contains(root, canonical))\n                    return options.notFound(request, response);\n                if (path !== canonical && options.redirectSymbolicLinks)\n                    return redirect(request, fs.relativeFromFile(path, canonical));\n                // TODO: relativeFromFile should be designed for URLs, not generalized paths.\n                // HTTP.relative(pathToDirectoryLocation(path), pathToFile/DirectoryLocation(canonical))\n                return Q.when(fs.stat(canonical), function (stat) {\n                    if (stat.isFile()) {\n                        return options.file(request, canonical, options.contentType, fs);\n                    } else if (stat.isDirectory()) {\n                        return options.directory(request, canonical, options.contentType);\n                    } else {\n                        return options.notFound(request, response);\n                    }\n                });\n            }, function (reason) {\n                return options.notFound(request, response);\n            });\n        });\n    };\n};\n\nexports.file = function (request, path, contentType, fs) {\n    fs = fs || FS;\n    // TODO last-modified header\n    contentType = contentType || MimeTypes.lookup(path);\n    return Q.when(fs.stat(path), function (stat) {\n        var etag = exports.etag(stat);\n        var options = {\n            flags: \"rb\"\n        };\n        var range;\n        var status = 200;\n        var headers = {\n            \"content-type\": contentType,\n            etag: etag\n        };\n\n        // Partial range requests\n        if (\"range\" in request.headers) {\n            // Invalid cache\n            if (\n                \"if-range\" in request.headers &&\n                etag != request.headers[\"if-range\"]\n            ) {\n                // Normal 200 for entire, altered content\n            } else {\n                // Truncate to the first requested continuous range\n                range = interpretFirstRange(request.headers[\"range\"]);\n                // Like Apache, ignore the range header if it is invalid\n                if (range) {\n                    if (range.end > stat.size)\n                        return StatusApps.responseForStatus(request, 416); // not satisfiable\n                    status = 206; // partial content\n                    headers[\"content-range\"] = (\n                        \"bytes \" +\n                        range.begin + \"-\" + (range.end - 1) +\n                        \"/\" + stat.size\n                    );\n                    headers[\"content-length\"] = \"\" + (range.end - range.begin);\n                }\n                options.begin = range.begin;\n                options.end = range.end;\n            }\n        // Full requests\n        } else {\n            // Cached\n            // We do not use date-based caching\n            // TODO consider if-match?\n            if (etag == request.headers[\"if-none-match\"])\n                return StatusApps.responseForStatus(request, 304);\n            headers[\"content-length\"] = \"\" + stat.size;\n        }\n\n        // TODO sendfile\n        return {\n            status: status,\n            headers: headers,\n            body: fs.open(path, options),\n            file: path,\n            range: range\n        };\n    });\n};\n\nvar rangesExpression = /^\\s*bytes\\s*=\\s*(\\d*\\s*-\\s*\\d*\\s*(?:,\\s*\\d*\\s*-\\s*\\d*\\s*)*)$/;\nvar rangeExpression = /^\\s*(\\d*)\\s*-\\s*(\\d*)\\s*$/;\n\nvar interpretRange = function (text, size) {\n    var match = rangeExpression.exec(text);\n    if (!match)\n        return;\n    if (match[1] == \"\" && match[2] == \"\")\n        return;\n    var begin, end;\n    if (match[1] == \"\") {\n        begin = size - match[2];\n        end = size;\n    } else if (match[2] == \"\") {\n        begin = +match[1];\n        end = size;\n    } else {\n        begin = +match[1];\n        end = +match[2] + 1;\n    }\n    return {\n        begin: begin,\n        end: end\n    };\n};\n\nvar interpretFirstRange = exports.interpretFirstRange = function (text, size) {\n    var match = rangesExpression.exec(text);\n    if (!match)\n        return;\n    var texts = match[1].split(/\\s*,\\s*/);\n    var range = interpretRange(texts[0], size);\n    for (var i = 0, ii = texts.length; i < ii; i++) {\n        var next = interpretRange(texts[i], size);\n        if (!next)\n            break;\n        if (next.begin <= range.end) {\n            range.end = next.end;\n        } else {\n            break;\n        }\n    }\n    return range;\n};\n\n/**\n * @param {Stat}\n * @returns {String}\n */\nexports.etag = function (stat) {\n    return [\n        stat.node.ino,\n        stat.size,\n        stat.lastModified().getTime()\n    ].join(\"-\");\n};\n\n/**\n * @param {Request} request\n * @param {String} path\n * @param {Response}\n */\nexports.directory = function (request, path) {\n    var response = StatusApps.notFound(request);\n    response.directory = path;\n    return response;\n};\n\nexports.ListDirectories = function (app, listDirectory) {\n    listDirectory = listDirectory || exports.listDirectory;\n    return function (request) {\n        if (request.directoryIndex) {\n            throw new Error(\"DirectoryIndex must be used after ListDirectories\");\n        }\n        request.listDirectories = true;\n        return Q.fcall(app, request)\n        .then(function (response) {\n            if (response.directory !== void 0) {\n                return exports.listDirectory(request, response);\n            } else {\n                return response;\n            }\n        });\n    };\n};\n\nexports.listDirectory = function (request, response) {\n    // TODO advisory to have JSON or HTML fragment handler.\n    request.location = URL.parse(request.path);\n    if (request.location.file) {\n        return RedirectApps.redirect(request, request.location.file + \"/\");\n    }\n    var handlers = {};\n    handlers[\"text/plain\"] = exports.listDirectoryText;\n    handlers[\"text/markdown\"] = exports.listDirectoryMarkdown;\n    if (request.handleHtmlFragmentResponse) {\n        handlers[\"text/html\"] = exports.listDirectoryHtmlFragment;\n    }\n    if (request.handleJsonResponse) {\n        handlers[\"application/json\"] = exports.listDirectoryJson;\n    }\n    var handleResponse = Negotiation.negotiate(request, handlers) || function () {\n        return response;\n    };\n    return handleResponse(request, response);\n};\n\nexports.listDirectoryHtmlFragment = function (request, response) {\n    return exports.listDirectoryData(request, response)\n    .then(function (data) {\n        return {\n            status: 200,\n            headers: {\n                \"content-type\": \"text/html\"\n            },\n            htmlTitle: \"Directory Index\",\n            htmlFragment: {\n                forEach: function (write) {\n                    write(\"<ul class=\\\"directory-index\\\">\\n\");\n                    Object.keys(data).sort().forEach(function (name) {\n                        var stat = data[name];\n                        var suffix = \"\";\n                        if (stat.type === \"directory\") {\n                            suffix = \"/\";\n                        }\n                        write(\"    <li class=\\\"entry \" + stat.type + \"\\\"><a href=\\\"\" + HtmlApps.escapeHtml(name + suffix) + \"\\\">\" + HtmlApps.escapeHtml(name + suffix) + \"</a></li>\\n\");\n                    });\n                    write(\"</ul>\\n\");\n                }\n            }\n        };\n    });\n};\n\nexports.listDirectoryText = function (request, response) {\n    return exports.listDirectoryData(request, response)\n    .then(function (data) {\n        return {\n            status: 200,\n            headers: {\n                \"content-type\": \"text/plain\"\n            },\n            body: {\n                forEach: function (write) {\n                    Object.keys(data).sort().forEach(function (name) {\n                        var stat = data[name];\n                        var suffix = \"\";\n                        if (stat.type === \"directory\") {\n                            suffix = \"/\";\n                        }\n                        write(name + suffix + \"\\n\");\n                    });\n                }\n            }\n        };\n    });\n};\n\nexports.listDirectoryMarkdown = function (request, response) {\n    return exports.listDirectoryData(request, response)\n    .then(function (data) {\n        return {\n            status: 200,\n            headers: {\n                \"content-type\": \"text/plain\"\n            },\n            body: {\n                forEach: function (write) {\n                    write(\"\\n# Directory Index\\n\\n\");\n                    Object.keys(data).forEach(function (name) {\n                        var stat = data[name];\n                        var suffix = \"\";\n                        if (stat.type === \"directory\") {\n                            suffix = \"/\";\n                        }\n                        write(\"-   \" + name + suffix + \"\\n\");\n                    });\n                    write(\"\\n\");\n                }\n            }\n        };\n    });\n};\n\nexports.listDirectoryJson = function (request, response) {\n    return exports.listDirectoryData(request, response)\n    .then(function (data) {\n        return {\n            status: 200,\n            headers: {},\n            data: data\n        };\n    });\n};\n\nexports.listDirectoryData = function (request, response) {\n    if (!request.fs) {\n        throw new Error(\"Can't list a directory without a designated file system\");\n    }\n    var fs = request.fs;\n    return Q.invoke(fs, \"list\", response.directory)\n    .then(function (list) {\n        list.sort();\n        return list.map(function (name) {\n            return Q.invoke(fs, \"stat\", fs.join(response.directory, name))\n            .then(function (stat) {\n                if (stat.isDirectory()) {\n                    return {name: name, stat: {\n                        type: \"directory\"\n                    }};\n                } else if (stat.isFile()) {\n                    return {name: name, stat: {\n                        type: \"file\"\n                    }};\n                }\n            }, function () {\n                // ignore unstatable entries\n            });\n        })\n    })\n    .all()\n    .then(function (stats) {\n        var data = {};\n        stats.forEach(function (entry) {\n            if (entry) {\n                data[entry.name] = entry.stat;\n            }\n        });\n        return data;\n    });\n};\n\nexports.DirectoryIndex = function (app, indexFile) {\n    indexFile = indexFile || \"index.html\";\n    return function (request) {\n        request.directoryIndex = true;\n        request.location = URL.parse(request.path);\n        // redirect index.html to containing directory\n        // TODO worry about whether this file actually exists\n        if (request.location.file === indexFile) {\n            return RedirectApps.redirect(request, \".\");\n        } else {\n            return Q.fcall(app, request)\n            .then(function (response) {\n                if (response.directory !== void 0) {\n                    if (request.location.file) {\n                        return RedirectApps.redirect(request, request.location.file + \"/\");\n                    } else {\n                        var index = request.fs.join(response.directory, indexFile);\n                        return Q.invoke(request.fs, \"isFile\", index)\n                        .then(function (isFile) {\n                            if (isFile) {\n                                request.url = URL.resolve(request.url, indexFile);\n                                request.pathInfo += indexFile;\n                                return app(request);\n                            } else {\n                                return response;\n                            }\n                        });\n                    }\n                } else {\n                    return response;\n                }\n            });\n        }\n    };\n};","blocks":{"total":88,"seen":49,"missing":39,"percentage":0.5568181818181818}},"hash":"ed8234221202f5a9139d3370e269d66c"},"/Users/kris/q-io/http-apps/redirect.js":{"stats":{"percentage":0.7330097087378641,"lines":[{"lineno":12},{"lineno":13},{"lineno":23},{"lineno":24},{"lineno":34},{"lineno":35},{"lineno":45},{"lineno":46},{"lineno":56},{"lineno":57},{"lineno":67},{"lineno":68},{"lineno":73},{"lineno":77},{"lineno":81},{"lineno":85},{"lineno":89},{"lineno":100},{"lineno":103},{"lineno":108},{"lineno":110},{"lineno":114},{"lineno":115},{"lineno":117},{"lineno":119},{"lineno":120},{"lineno":125},{"lineno":126},{"lineno":129},{"lineno":130},{"lineno":141},{"lineno":142},{"lineno":151},{"lineno":152},{"lineno":153},{"lineno":154},{"lineno":163},{"lineno":164},{"lineno":165},{"lineno":166},{"lineno":167},{"lineno":168},{"lineno":170},{"lineno":174},{"lineno":175},{"lineno":177},{"lineno":178},{"lineno":179},{"lineno":180},{"lineno":181},{"lineno":183},{"lineno":186},{"lineno":191},{"lineno":193},{"lineno":198}],"missing":55,"seen":151,"total":206,"coverage":{"12":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"13":{"partial":false,"source":"        return exports.permanentRedirect(request, location, status, tree);","missing":[{"startCol":8,"endCol":74},{"startCol":15,"endCol":73},{}]},"14":{"partial":false,"source":"    };","missing":[{}]},"23":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"24":{"partial":false,"source":"        return exports.permanentRedirect(request, location, status, true);","missing":[{"startCol":8,"endCol":74},{"startCol":15,"endCol":73},{}]},"25":{"partial":false,"source":"    };","missing":[{}]},"34":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"35":{"partial":false,"source":"        return exports.temporaryRedirect(request, location, status, tree);","missing":[{"startCol":8,"endCol":74},{"startCol":15,"endCol":73},{}]},"36":{"partial":false,"source":"    };","missing":[{}]},"45":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"46":{"partial":false,"source":"        return exports.temporaryRedirect(request, location, status, true);","missing":[{"startCol":8,"endCol":74},{"startCol":15,"endCol":73},{}]},"47":{"partial":false,"source":"    };","missing":[{}]},"56":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"57":{"partial":false,"source":"        return exports.redirect(request, location, status, tree);","missing":[{},{"startCol":8,"endCol":65},{"startCol":15,"endCol":64}]},"58":{"partial":false,"source":"    };","missing":[{}]},"67":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"68":{"partial":false,"source":"        return exports.redirect(request, location, status, true);","missing":[{},{"startCol":8,"endCol":65},{"startCol":15,"endCol":64}]},"69":{"partial":false,"source":"    };","missing":[{}]},"73":{"partial":false,"source":"    return exports.redirect(request, location, status || 301);","missing":[{"startCol":4,"endCol":62},{"startCol":11,"endCol":61},{"startCol":47,"endCol":60}]},"77":{"partial":false,"source":"    return exports.redirect(request, location, status || 301, true);","missing":[{"startCol":4,"endCol":68},{"startCol":11,"endCol":67},{"startCol":47,"endCol":60}]},"81":{"partial":false,"source":"    return exports.redirect(request, location, status || 307);","missing":[{"startCol":4,"endCol":62},{"startCol":11,"endCol":61},{"startCol":47,"endCol":60}]},"85":{"partial":false,"source":"    return exports.redirect(request, location, status || 307, true);","missing":[{"startCol":4,"endCol":68},{"startCol":11,"endCol":67},{"startCol":47,"endCol":60}]},"89":{"partial":false,"source":"    return exports.redirect(request, location, status, true);","missing":[{"startCol":4,"endCol":61},{"startCol":11,"endCol":60}]},"100":{"partial":false,"source":"    status = status || (request.permanent ? 301 : 307);","missing":[{"startCol":4,"endCol":55},{"startCol":13,"endCol":54},{"startCol":44,"endCol":47},{"startCol":50,"endCol":53}]},"103":{"partial":false,"source":"    location = URL.resolve(request.url, location);","missing":[{"startCol":4,"endCol":50},{"startCol":15,"endCol":49}]},"108":{"partial":false,"source":"        location = URL.resolve(","missing":[{}]},"109":{"partial":false,"source":"            location,","missing":[{}]},"110":{"partial":false,"source":"            request.pathInfo.replace(/^\\//, \"\")","missing":[{},{"startCol":12,"endCol":47}]},"111":{"partial":false,"source":"        );","missing":[{}]},"114":{"partial":false,"source":"    var handlers = {};","missing":[{"startCol":4,"endCol":22}]},"115":{"partial":false,"source":"    handlers[\"text/plain\"] = exports.redirectText;","missing":[{"startCol":4,"endCol":50}]},"117":{"partial":false,"source":"        handlers[\"text/html\"] = exports.redirectHtml;","missing":[{"startCol":8,"endCol":53}]},"119":{"partial":false,"source":"    var handler = Negotiation.negotiate(request, handlers) || exports.redirectText;","missing":[{"startCol":4,"endCol":83},{"startCol":18,"endCol":58}]},"120":{"partial":false,"source":"    return handler(request, location, status);","missing":[{"startCol":4,"endCol":46},{"startCol":11,"endCol":45}]},"125":{"partial":false,"source":"    var content = (","missing":[{}]},"126":{"partial":false,"source":"        (request.permanent ? \"Permanent redirect\\n\" : \"Temporary redirect\\n\") +","missing":[{},{"startCol":29,"endCol":51},{"startCol":54,"endCol":76}]},"127":{"partial":false,"source":"        \"See: \" + location + \"\\n\"","missing":[{}]},"128":{"partial":false,"source":"    );","missing":[{}]},"129":{"partial":false,"source":"    var contentLength = content.length;","missing":[{"startCol":4,"endCol":39}]},"130":{"partial":false,"source":"    return {","missing":[{}]},"131":{"partial":false,"source":"        status: status,","missing":[{}]},"132":{"partial":false,"source":"        headers: {","missing":[{}]},"133":{"partial":false,"source":"            location: location,","missing":[{}]},"134":{"partial":false,"source":"            \"content-type\": \"text/plain\"","missing":[{}]},"135":{"partial":false,"source":"        },","missing":[{}]},"136":{"partial":false,"source":"        body: [content]","missing":[{}]},"137":{"partial":false,"source":"    };","missing":[{}]},"141":{"partial":false,"source":"    var title = request.permanent ? \"Permanent redirect\" : \"Temporary redirect\";","missing":[{"startCol":4,"endCol":80},{"startCol":36,"endCol":56},{"startCol":59,"endCol":79}]},"142":{"partial":false,"source":"    return {","missing":[{}]},"143":{"partial":false,"source":"        status: status,","missing":[{}]},"144":{"partial":false,"source":"        headers: {","missing":[{}]},"145":{"partial":false,"source":"            location: location,","missing":[{}]},"146":{"partial":false,"source":"            \"content-type\": \"text/html\"","missing":[{}]},"147":{"partial":false,"source":"        },","missing":[{}]},"148":{"partial":false,"source":"        htmlTitle: title,","missing":[{}]},"149":{"partial":false,"source":"        htmlFragment: {","missing":[{}]},"150":{"partial":false,"source":"            forEach: function (write) {","missing":[{}]},"151":{"partial":false,"source":"                write(\"<h1>\" + HtmlApps.escapeHtml(title) + \"</h1>\\n\");","missing":[{"startCol":16,"endCol":70},{"startCol":22,"endCol":57},{"startCol":31,"endCol":57},{}]},"152":{"partial":false,"source":"                write(","missing":[{}]},"153":{"partial":false,"source":"                    \"<p>See: <a href=\\\"\" + HtmlApps.escapeHtml(location) + \"\\\">\" +","missing":[{},{"startCol":20,"endCol":72},{"startCol":43,"endCol":72}]},"154":{"partial":false,"source":"                    HtmlApps.escapeHtml(location) +","missing":[{},{"startCol":20,"endCol":49}]},"155":{"partial":false,"source":"                    \"</a></p>\\n\"","missing":[{}]},"156":{"partial":false,"source":"                );","missing":[{}]},"157":{"partial":false,"source":"            }","missing":[{}]},"158":{"partial":false,"source":"        }","missing":[{}]},"159":{"partial":false,"source":"    };","missing":[{}]},"163":{"partial":false,"source":"    maxRedirects = maxRedirects || 20;","missing":[{"startCol":4,"endCol":38},{"startCol":19,"endCol":37}]},"164":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"165":{"partial":false,"source":"        var remaining = maxRedirects;","missing":[{"startCol":8,"endCol":37},{}]},"166":{"partial":false,"source":"        var deferred = Q.defer();","missing":[{},{"startCol":23,"endCol":32},{"startCol":8,"endCol":33}]},"167":{"partial":false,"source":"        var self = this;","missing":[{"startCol":8,"endCol":24},{}]},"168":{"partial":false,"source":"        var args = arguments;","missing":[{"startCol":8,"endCol":29},{}]},"169":{"partial":false,"source":"","missing":[{}]},"170":{"partial":false,"source":"        request = HTTP.normalizeRequest(request);","missing":[{"startCol":8,"endCol":49},{},{"startCol":18,"endCol":48}]},"171":{"partial":false,"source":"","missing":[{}]},"172":{"partial":false,"source":"        // try redirect loop","missing":[{}]},"173":{"partial":false,"source":"        function next() {","missing":[{}]},"174":{"partial":false,"source":"            Q.fcall(function () {","missing":[{}]},"175":{"partial":false,"source":"                return app(request, response);","missing":[{"startCol":16,"endCol":46},{},{"startCol":23,"endCol":45}]},"176":{"partial":false,"source":"            })","missing":[{}]},"177":{"partial":false,"source":"            .then(function (response) {","missing":[{}]},"178":{"partial":false,"source":"                if (exports.isRedirect(response)) {","missing":[{},{"startCol":20,"endCol":48}]},"179":{"partial":false,"source":"                    if (remaining--) {","missing":[{},{"startCol":24,"endCol":35}]},"180":{"partial":false,"source":"                        request.url = response.headers.location;","missing":[{},{"startCol":24,"endCol":64}]},"181":{"partial":false,"source":"                        next();","missing":[{"startCol":24,"endCol":30},{}]},"182":{"partial":false,"source":"                    } else {","missing":[{}]},"183":{"partial":false,"source":"                        throw new Error(\"Maximum redirects.\");","missing":[{},{"startCol":24,"endCol":62}]},"184":{"partial":false,"source":"                    }","missing":[{}]},"185":{"partial":false,"source":"                } else {","missing":[{}]},"186":{"partial":false,"source":"                    deferred.resolve(response);","missing":[{},{"startCol":20,"endCol":47}]},"187":{"partial":false,"source":"                }","missing":[{}]},"188":{"partial":false,"source":"            })","missing":[{}]},"189":{"partial":false,"source":"            .fail(deferred.reject)","missing":[{}]},"190":{"partial":false,"source":"        }","missing":[{}]},"191":{"partial":false,"source":"        next();","missing":[{"startCol":8,"endCol":14},{}]},"192":{"partial":false,"source":"","missing":[{}]},"193":{"partial":false,"source":"        return deferred.promise;","missing":[{"startCol":8,"endCol":32},{}]},"194":{"partial":false,"source":"    };","missing":[{}]},"198":{"partial":false,"source":"    return isRedirect[response.status] || false;","missing":[{"startCol":4,"endCol":48},{"startCol":11,"endCol":47}]}},"source":"var Q = require(\"q\");\nvar URL = require(\"url2\");\nvar Negotiation = require(\"./negotiate\");\nvar HtmlApps = require(\"./html\");\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `301`\n * @returns {App}\n */\nexports.PermanentRedirect = function (location, status, tree) {\n    return function (request, response) {\n        return exports.permanentRedirect(request, location, status, tree);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `301`\n * @returns {App}\n */\nexports.PermanentRedirectTree = function (location, status) {\n    return function (request, response) {\n        return exports.permanentRedirect(request, location, status, true);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.TemporaryRedirect = function (location, status, tree) {\n    return function (request, response) {\n        return exports.temporaryRedirect(request, location, status, tree);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.TemporaryRedirectTree = function (location, status) {\n    return function (request, response) {\n        return exports.temporaryRedirect(request, location, status, true);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.Redirect = function (location, status, tree) {\n    return function (request, response) {\n        return exports.redirect(request, location, status, tree);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.RedirectTree = function (location, status) {\n    return function (request, response) {\n        return exports.redirect(request, location, status, true);\n    };\n};\n\nexports.permanentRedirect = function (request, location, status) {\n    return exports.redirect(request, location, status || 301);\n};\n\nexports.permanentRedirectTree = function (request, location, status) {\n    return exports.redirect(request, location, status || 301, true);\n};\n\nexports.temporaryRedirect = function (request, location, status) {\n    return exports.redirect(request, location, status || 307);\n};\n\nexports.temporaryRedirectTree = function (request, location, status) {\n    return exports.redirect(request, location, status || 307, true);\n};\n\nexports.redirectTree = function (request, location, status) {\n    return exports.redirect(request, location, status, true);\n};\n\n/**\n * @param {String} location\n * @param {Number} status (optional) default is `301`\n * @returns {Response}\n */\nexports.redirect = function (request, location, status, tree) {\n\n    // request.permanent gets set by Permanent middleware\n    status = status || (request.permanent ? 301 : 307);\n\n    // ascertain that the location is absolute, per spec\n    location = URL.resolve(request.url, location);\n\n    // redirect into a subtree with the remaining unrouted\n    // portion of the path, if so configured\n    if (tree) {\n        location = URL.resolve(\n            location,\n            request.pathInfo.replace(/^\\//, \"\")\n        );\n    }\n\n    var handlers = {};\n    handlers[\"text/plain\"] = exports.redirectText;\n    if (request.handleHtmlFragmentResponse) {\n        handlers[\"text/html\"] = exports.redirectHtml;\n    }\n    var handler = Negotiation.negotiate(request, handlers) || exports.redirectText;\n    return handler(request, location, status);\n\n};\n\nexports.redirectText = function (request, location, status) {\n    var content = (\n        (request.permanent ? \"Permanent redirect\\n\" : \"Temporary redirect\\n\") +\n        \"See: \" + location + \"\\n\"\n    );\n    var contentLength = content.length;\n    return {\n        status: status,\n        headers: {\n            location: location,\n            \"content-type\": \"text/plain\"\n        },\n        body: [content]\n    };\n};\n\nexports.redirectHtml = function (request, location, status) {\n    var title = request.permanent ? \"Permanent redirect\" : \"Temporary redirect\";\n    return {\n        status: status,\n        headers: {\n            location: location,\n            \"content-type\": \"text/html\"\n        },\n        htmlTitle: title,\n        htmlFragment: {\n            forEach: function (write) {\n                write(\"<h1>\" + HtmlApps.escapeHtml(title) + \"</h1>\\n\");\n                write(\n                    \"<p>See: <a href=\\\"\" + HtmlApps.escapeHtml(location) + \"\\\">\" +\n                    HtmlApps.escapeHtml(location) +\n                    \"</a></p>\\n\"\n                );\n            }\n        }\n    };\n};\n\nexports.RedirectTrap = function (app, maxRedirects) {\n    maxRedirects = maxRedirects || 20;\n    return function (request, response) {\n        var remaining = maxRedirects;\n        var deferred = Q.defer();\n        var self = this;\n        var args = arguments;\n\n        request = HTTP.normalizeRequest(request);\n\n        // try redirect loop\n        function next() {\n            Q.fcall(function () {\n                return app(request, response);\n            })\n            .then(function (response) {\n                if (exports.isRedirect(response)) {\n                    if (remaining--) {\n                        request.url = response.headers.location;\n                        next();\n                    } else {\n                        throw new Error(\"Maximum redirects.\");\n                    }\n                } else {\n                    deferred.resolve(response);\n                }\n            })\n            .fail(deferred.reject)\n        }\n        next();\n\n        return deferred.promise;\n    };\n};\n\nexports.isRedirect = function (response) {\n    return isRedirect[response.status] || false;\n};\n\nvar isRedirect = {\n    301: true,\n    302: true,\n    303: true,\n    307: true\n};","blocks":{"total":33,"seen":0,"missing":33,"percentage":0}},"hash":"b2e296e439b2cca87204447302d0c868"},"/Users/kris/q-io/http-apps/json.js":{"stats":{"percentage":0.72,"lines":[{"lineno":4},{"lineno":5},{"lineno":6},{"lineno":8},{"lineno":9},{"lineno":11},{"lineno":18},{"lineno":19},{"lineno":21},{"lineno":24},{"lineno":37},{"lineno":38},{"lineno":39},{"lineno":52},{"lineno":54},{"lineno":56},{"lineno":66},{"lineno":67},{"lineno":69},{"lineno":71},{"lineno":73}],"missing":21,"seen":54,"total":75,"coverage":{"4":{"partial":false,"source":"    return function (request) {","missing":[{}]},"5":{"partial":false,"source":"        request.handleJsonResponse = exports.handleJsonResponse;","missing":[{"startCol":8,"endCol":64},{}]},"6":{"partial":false,"source":"        return Q.fcall(app, request)","missing":[{"startCol":22,"endCol":36},{}]},"7":{"partial":false,"source":"        .then(function (response) {","missing":[{}]},"8":{"partial":false,"source":"            if (response.data !== void 0) {","missing":[{},{"startCol":16,"endCol":40}]},"9":{"partial":false,"source":"                return Q.fcall(exports.handleJsonResponse, response, reviver, tab);","missing":[{"startCol":16,"endCol":83},{},{"startCol":23,"endCol":82}]},"10":{"partial":false,"source":"            } else {","missing":[{}]},"11":{"partial":false,"source":"                return response;","missing":[{},{"startCol":16,"endCol":32}]},"12":{"partial":false,"source":"            }","missing":[{}]},"13":{"partial":false,"source":"        });","missing":[{}]},"14":{"partial":false,"source":"    };","missing":[{}]},"18":{"partial":false,"source":"    response.headers[\"content-type\"] = \"application/json\";","missing":[{"startCol":4,"endCol":58}]},"19":{"partial":false,"source":"    response.body = {","missing":[{}]},"20":{"partial":false,"source":"        forEach: function (write) {","missing":[{}]},"21":{"partial":false,"source":"            write(JSON.stringify(response.data, revivier, tab));","missing":[{},{"startCol":12,"endCol":63},{"startCol":18,"endCol":62}]},"22":{"partial":false,"source":"        }","missing":[{}]},"23":{"partial":false,"source":"    };","missing":[{}]},"24":{"partial":false,"source":"    return response;","missing":[{"startCol":4,"endCol":20}]},"37":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"38":{"partial":false,"source":"        return Q.when(app(request, response), function (object) {","missing":[{},{"startCol":22,"endCol":44}]},"39":{"partial":false,"source":"            return exports.json(object, reviver, tabs);","missing":[{"startCol":12,"endCol":55},{},{"startCol":19,"endCol":54}]},"40":{"partial":false,"source":"        });","missing":[{}]},"41":{"partial":false,"source":"    };","missing":[{}]},"52":{"partial":false,"source":"        var json = JSON.stringify(content, reviver, tabs);","missing":[{"startCol":8,"endCol":58},{"startCol":19,"endCol":57}]},"54":{"partial":false,"source":"        return Q.reject(exception);","missing":[{"startCol":8,"endCol":35},{"startCol":15,"endCol":34}]},"56":{"partial":false,"source":"    return exports.ok([json]);","missing":[{"startCol":4,"endCol":30},{"startCol":11,"endCol":29}]},"66":{"partial":false,"source":"        badRequest = exports.badRequest;","missing":[{"startCol":8,"endCol":40}]},"67":{"partial":false,"source":"    return exports.ContentRequest(function (content, request, response) {","missing":[{}]},"68":{"partial":false,"source":"        try {","missing":[{}]},"69":{"partial":false,"source":"            var object = JSON.parse(content);","missing":[{"startCol":25,"endCol":44},{},{"startCol":12,"endCol":45}]},"70":{"partial":false,"source":"        } catch (error) {","missing":[{}]},"71":{"partial":false,"source":"            return badRequest(request, error);","missing":[{},{"startCol":19,"endCol":45},{"startCol":12,"endCol":46}]},"72":{"partial":false,"source":"        }","missing":[{}]},"73":{"partial":false,"source":"        return app(object, request, response);","missing":[{"startCol":8,"endCol":46},{"startCol":15,"endCol":45},{}]},"74":{"partial":false,"source":"    });","missing":[{}]}},"source":"var Q = require(\"q\");\n\nexports.HandleJsonResponses = function (app, reviver, tab) {\n    return function (request) {\n        request.handleJsonResponse = exports.handleJsonResponse;\n        return Q.fcall(app, request)\n        .then(function (response) {\n            if (response.data !== void 0) {\n                return Q.fcall(exports.handleJsonResponse, response, reviver, tab);\n            } else {\n                return response;\n            }\n        });\n    };\n};\n\nexports.handleJsonResponse = function (response, revivier, tab) {\n    response.headers[\"content-type\"] = \"application/json\";\n    response.body = {\n        forEach: function (write) {\n            write(JSON.stringify(response.data, revivier, tab));\n        }\n    };\n    return response;\n};\n\n/**\n * Wraps a Q-JSGI application such that the child application may\n * simply return an object, which will in turn be serialized into a\n * Q-JSGI response.\n *\n * @param {Function(Request):Object} app an application that accepts a\n * request and returns a JSON serializable object.\n * @returns {App}\n */\nexports.Json = function (app, reviver, tabs) {\n    return function (request, response) {\n        return Q.when(app(request, response), function (object) {\n            return exports.json(object, reviver, tabs);\n        });\n    };\n};\n\n/**\n * @param {Object} content data to serialize as JSON\n * @param {Function} reviver\n * @param {Number|String} tabs\n * @returns {Response}\n */\nexports.json = function (content, reviver, tabs) {\n    try {\n        var json = JSON.stringify(content, reviver, tabs);\n    } catch (exception) {\n        return Q.reject(exception);\n    }\n    return exports.ok([json]);\n};\n\n/**\n * @param {Function(Request, Object):Response} app\n * @param {App} badRequest\n * @returns {App}\n */\nexports.JsonRequest = function (app, badRequest) {\n    if (!badRequest)\n        badRequest = exports.badRequest;\n    return exports.ContentRequest(function (content, request, response) {\n        try {\n            var object = JSON.parse(content);\n        } catch (error) {\n            return badRequest(request, error);\n        }\n        return app(object, request, response);\n    });\n};","blocks":{"total":18,"seen":0,"missing":18,"percentage":0}},"hash":"62ff46be37161c80b2d3774f927424c0"},"/Users/kris/q-io/http-apps/proxy.js":{"stats":{"percentage":0.84,"lines":[{"lineno":7},{"lineno":8},{"lineno":9},{"lineno":10}],"missing":4,"seen":21,"total":25,"coverage":{"7":{"partial":false,"source":"        var location = app;","missing":[{"startCol":8,"endCol":27}]},"8":{"partial":false,"source":"        app = function (request) {","missing":[{}]},"9":{"partial":false,"source":"            request.url = location;","missing":[{"startCol":12,"endCol":35},{}]},"10":{"partial":false,"source":"            return request;","missing":[{"startCol":12,"endCol":27},{}]},"11":{"partial":false,"source":"        };","missing":[{}]}},"source":"var HTTP = require(\"../http\");\nvar URL = require(\"url2\");\nvar Q = require(\"q\");\n\nexports.Proxy = function (app) {\n    if (typeof app === \"string\") {\n        var location = app;\n        app = function (request) {\n            request.url = location;\n            return request;\n        };\n    }\n    return function (request, response) {\n        return Q.when(app.apply(this, arguments), function (request) {\n            return HTTP.request(request);\n        });\n    };\n};\n\nexports.ProxyTree = function (url) {\n    return exports.Proxy(function (request) {\n        request.url = URL.resolve(url, request.pathInfo.replace(/^\\//, \"\"));\n        return request;\n    });\n};","blocks":{"total":7,"seen":5,"missing":2,"percentage":0.7142857142857143}},"hash":"b79408847e087a2021c47d2ba22cc543"},"/Users/kris/q-io/http-apps/decorators.js":{"stats":{"percentage":0.6875,"lines":[{"lineno":16},{"lineno":17},{"lineno":19},{"lineno":20},{"lineno":32},{"lineno":33},{"lineno":35},{"lineno":36},{"lineno":42},{"lineno":53},{"lineno":54},{"lineno":55},{"lineno":57},{"lineno":58},{"lineno":59},{"lineno":61},{"lineno":62},{"lineno":64},{"lineno":65},{"lineno":66},{"lineno":70},{"lineno":72},{"lineno":73},{"lineno":77},{"lineno":80},{"lineno":81},{"lineno":87},{"lineno":89},{"lineno":90},{"lineno":93},{"lineno":95},{"lineno":110},{"lineno":111},{"lineno":112},{"lineno":113},{"lineno":114},{"lineno":115},{"lineno":117},{"lineno":131},{"lineno":132},{"lineno":133},{"lineno":134},{"lineno":135},{"lineno":136},{"lineno":140},{"lineno":153},{"lineno":154},{"lineno":156},{"lineno":157},{"lineno":159},{"lineno":160},{"lineno":162},{"lineno":172},{"lineno":173},{"lineno":175}],"missing":55,"seen":121,"total":176,"coverage":{"16":{"partial":false,"source":"    present = present || function () {","missing":[{}]},"17":{"partial":false,"source":"        return new Date();","missing":[{"startCol":8,"endCol":26},{}]},"18":{"partial":false,"source":"    };","missing":[{}]},"19":{"partial":false,"source":"    return RouteApps.Trap(app, function (response, request) {","missing":[{}]},"20":{"partial":false,"source":"        response.headers[\"date\"] = \"\" + present();","missing":[{"startCol":8,"endCol":50},{"startCol":40,"endCol":49},{},{"startCol":35,"endCol":49}]},"21":{"partial":false,"source":"    });","missing":[{}]},"32":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"33":{"partial":false,"source":"        return Q.when(app(request, response), null, function (error) {","missing":[{},{"startCol":22,"endCol":44}]},"34":{"partial":false,"source":"            if (!debug)","missing":[{}]},"35":{"partial":false,"source":"                error = undefined;","missing":[{"startCol":16,"endCol":34},{}]},"36":{"partial":false,"source":"            return StatusApps.responseForStatus(request, 500, error && error.stack || error);","missing":[{"startCol":62,"endCol":82},{},{"startCol":12,"endCol":93},{"startCol":19,"endCol":92}]},"37":{"partial":false,"source":"        });","missing":[{}]},"38":{"partial":false,"source":"    };","missing":[{}]},"42":{"partial":false,"source":"    return exports.Error(app, true);","missing":[{"startCol":4,"endCol":36},{"startCol":11,"endCol":35}]},"53":{"partial":false,"source":"    log = log || console.log;","missing":[{"startCol":4,"endCol":29},{"startCol":10,"endCol":28}]},"54":{"partial":false,"source":"    stamp = stamp || function (message) {","missing":[{}]},"55":{"partial":false,"source":"        return new Date().toISOString() + \" \" + message;","missing":[{"startCol":8,"endCol":56},{"startCol":15,"endCol":45},{}]},"56":{"partial":false,"source":"    };","missing":[{}]},"57":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"58":{"partial":false,"source":"        var remoteHost =","missing":[{}]},"59":{"partial":false,"source":"            request.remoteHost + \":\" +","missing":[{},{"startCol":12,"endCol":36}]},"60":{"partial":false,"source":"            request.remotePort;","missing":[{}]},"61":{"partial":false,"source":"        var requestLine =","missing":[{}]},"62":{"partial":false,"source":"            request.method + \" \" +","missing":[{},{"startCol":12,"endCol":32}]},"63":{"partial":false,"source":"            request.path + \" \" +","missing":[{}]},"64":{"partial":false,"source":"            \"HTTP/\" + request.version.join(\".\");","missing":[{"startCol":22,"endCol":47},{}]},"65":{"partial":false,"source":"        log(stamp(","missing":[{}]},"66":{"partial":false,"source":"            remoteHost + \" \" +","missing":[{},{"startCol":12,"endCol":28}]},"67":{"partial":false,"source":"            \"-->     \" +","missing":[{}]},"68":{"partial":false,"source":"            requestLine","missing":[{}]},"69":{"partial":false,"source":"        ));","missing":[{}]},"70":{"partial":false,"source":"        return Q.when(app(request, response), function (response) {","missing":[{},{"startCol":22,"endCol":44}]},"71":{"partial":false,"source":"            if (response) {","missing":[{}]},"72":{"partial":false,"source":"                log(stamp(","missing":[{}]},"73":{"partial":false,"source":"                    remoteHost + \" \" +","missing":[{},{"startCol":20,"endCol":36}]},"74":{"partial":false,"source":"                    \"<== \" +","missing":[{}]},"75":{"partial":false,"source":"                    response.status + \" \" +","missing":[{}]},"76":{"partial":false,"source":"                    requestLine + \" \" +","missing":[{}]},"77":{"partial":false,"source":"                    (response.headers[\"content-length\"] || \"-\")","missing":[{},{"startCol":20,"endCol":63}]},"78":{"partial":false,"source":"                ));","missing":[{}]},"79":{"partial":false,"source":"            } else {","missing":[{}]},"80":{"partial":false,"source":"                log(stamp(","missing":[{}]},"81":{"partial":false,"source":"                    remoteHost + \" \" +","missing":[{},{"startCol":20,"endCol":36}]},"82":{"partial":false,"source":"                    \"... \" +","missing":[{}]},"83":{"partial":false,"source":"                    \"... \" +","missing":[{}]},"84":{"partial":false,"source":"                    requestLine + \" (response undefined / presumed streaming)\"","missing":[{}]},"85":{"partial":false,"source":"                ));","missing":[{}]},"86":{"partial":false,"source":"            }","missing":[{}]},"87":{"partial":false,"source":"            return response;","missing":[{"startCol":12,"endCol":28},{}]},"88":{"partial":false,"source":"        }, function (reason) {","missing":[{}]},"89":{"partial":false,"source":"            log(stamp(","missing":[{}]},"90":{"partial":false,"source":"                remoteHost + \" \" +","missing":[{},{"startCol":16,"endCol":32}]},"91":{"partial":false,"source":"                \"!!!     \" +","missing":[{}]},"92":{"partial":false,"source":"                requestLine + \" \" +","missing":[{}]},"93":{"partial":false,"source":"                (reason && reason.message || reason)","missing":[{"startCol":16,"endCol":52},{},{"startCol":17,"endCol":41}]},"94":{"partial":false,"source":"            ));","missing":[{}]},"95":{"partial":false,"source":"            return Q.reject(reason);","missing":[{"startCol":12,"endCol":36},{"startCol":19,"endCol":35},{}]},"96":{"partial":false,"source":"        });","missing":[{}]},"97":{"partial":false,"source":"    };","missing":[{}]},"110":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"111":{"partial":false,"source":"        var start = new Date();","missing":[{},{"startCol":8,"endCol":31}]},"112":{"partial":false,"source":"        return Q.when(app(request, response), function (response) {","missing":[{},{"startCol":22,"endCol":44}]},"113":{"partial":false,"source":"            var stop = new Date();","missing":[{"startCol":12,"endCol":34},{}]},"114":{"partial":false,"source":"            if (response && response.headers) {","missing":[{},{"startCol":16,"endCol":44}]},"115":{"partial":false,"source":"                response.headers[\"x-response-time\"] = \"\" + (stop - start);","missing":[{"startCol":16,"endCol":74},{},{"startCol":54,"endCol":73},{"startCol":59,"endCol":73}]},"116":{"partial":false,"source":"            }","missing":[{}]},"117":{"partial":false,"source":"            return response;","missing":[{},{"startCol":12,"endCol":28}]},"118":{"partial":false,"source":"        });","missing":[{}]},"119":{"partial":false,"source":"    };","missing":[{}]},"131":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"132":{"partial":false,"source":"        return Q.when(app(request, response), function (response) {","missing":[{},{"startCol":22,"endCol":44}]},"133":{"partial":false,"source":"            if (response && response.headers) {","missing":[{},{"startCol":16,"endCol":44}]},"134":{"partial":false,"source":"                Object.keys(headers).forEach(function (key) {","missing":[{},{"startCol":27,"endCol":36}]},"135":{"partial":false,"source":"                    if (!(key in response.headers)) {","missing":[{},{"startCol":25,"endCol":50}]},"136":{"partial":false,"source":"                        response.headers[key] = headers[key];","missing":[{"startCol":24,"endCol":61},{}]},"137":{"partial":false,"source":"                    }","missing":[{}]},"138":{"partial":false,"source":"                });","missing":[{}]},"139":{"partial":false,"source":"            }","missing":[{}]},"140":{"partial":false,"source":"            return response;","missing":[{},{"startCol":12,"endCol":28}]},"141":{"partial":false,"source":"        });","missing":[{}]},"142":{"partial":false,"source":"    };","missing":[{}]},"153":{"partial":false,"source":"    future = future || function () {","missing":[{}]},"154":{"partial":false,"source":"        return new Date(new Date().getTime() + farFuture);","missing":[{"startCol":8,"endCol":58},{"startCol":24,"endCol":44},{}]},"155":{"partial":false,"source":"    };","missing":[{}]},"156":{"partial":false,"source":"    app = RouteApps.Tap(app, function (request, response) {","missing":[{}]},"157":{"partial":false,"source":"        request.permanent = future;","missing":[{"startCol":8,"endCol":35},{}]},"158":{"partial":false,"source":"    });","missing":[{}]},"159":{"partial":false,"source":"    app = RouteApps.Trap(app, function (response, request) {","missing":[{}]},"160":{"partial":false,"source":"        response.headers[\"expires\"] = \"\" + future();","missing":[{},{"startCol":8,"endCol":52},{"startCol":38,"endCol":51},{"startCol":43,"endCol":51}]},"161":{"partial":false,"source":"    });","missing":[{}]},"162":{"partial":false,"source":"    return app;","missing":[{"startCol":4,"endCol":15}]},"172":{"partial":false,"source":"    decorators.reversed().forEach(function (Middleware) {","missing":[{"startCol":23,"endCol":25},{}]},"173":{"partial":false,"source":"        app = Middleware(app);","missing":[{"startCol":14,"endCol":29},{},{"startCol":8,"endCol":30}]},"174":{"partial":false,"source":"    });","missing":[{}]},"175":{"partial":false,"source":"    return app;","missing":[{"startCol":4,"endCol":15}]}},"source":"var Q = require(\"q\");\nvar HTTP = require(\"../http\");\nvar RouteApps = require(\"./route\");\nvar StatusApps = require(\"./status\");\n\nexports.Normalize = function (app) {\n    return function (request, response) {\n        var request = HTTP.normalizeRequest(request);\n        return Q.when(app(request, response), function (response) {\n            return HTTP.normalizeResponse(response);\n        });\n    };\n};\n\nexports.Date = function (app, present) {\n    present = present || function () {\n        return new Date();\n    };\n    return RouteApps.Trap(app, function (response, request) {\n        response.headers[\"date\"] = \"\" + present();\n    });\n};\n\n/**\n * Decorates a JSGI application such that rejected response promises\n * get translated into `500` server error responses with no content.\n *\n * @param {App} app\n * @returns {App}\n */\nexports.Error = function (app, debug) {\n    return function (request, response) {\n        return Q.when(app(request, response), null, function (error) {\n            if (!debug)\n                error = undefined;\n            return StatusApps.responseForStatus(request, 500, error && error.stack || error);\n        });\n    };\n};\n\nexports.Debug = function (app) {\n    return exports.Error(app, true);\n};\n\n/**\n * Decorates a Q-JSGI application such that all requests and responses\n * are logged.\n *\n * @param {App} app\n * @returns {App}\n */\nexports.Log = function (app, log, stamp) {\n    log = log || console.log;\n    stamp = stamp || function (message) {\n        return new Date().toISOString() + \" \" + message;\n    };\n    return function (request, response) {\n        var remoteHost =\n            request.remoteHost + \":\" +\n            request.remotePort;\n        var requestLine =\n            request.method + \" \" +\n            request.path + \" \" +\n            \"HTTP/\" + request.version.join(\".\");\n        log(stamp(\n            remoteHost + \" \" +\n            \"-->     \" +\n            requestLine\n        ));\n        return Q.when(app(request, response), function (response) {\n            if (response) {\n                log(stamp(\n                    remoteHost + \" \" +\n                    \"<== \" +\n                    response.status + \" \" +\n                    requestLine + \" \" +\n                    (response.headers[\"content-length\"] || \"-\")\n                ));\n            } else {\n                log(stamp(\n                    remoteHost + \" \" +\n                    \"... \" +\n                    \"... \" +\n                    requestLine + \" (response undefined / presumed streaming)\"\n                ));\n            }\n            return response;\n        }, function (reason) {\n            log(stamp(\n                remoteHost + \" \" +\n                \"!!!     \" +\n                requestLine + \" \" +\n                (reason && reason.message || reason)\n            ));\n            return Q.reject(reason);\n        });\n    };\n};\n\n/**\n * Decorates a Q-JSGI application such that all responses have an\n * X-Response-Time header with the time between the request and the\n * response in milliseconds, not including any time needed to stream\n * the body to the client.\n *\n * @param {App} app\n * @returns {App}\n */\nexports.Time = function (app) {\n    return function (request, response) {\n        var start = new Date();\n        return Q.when(app(request, response), function (response) {\n            var stop = new Date();\n            if (response && response.headers) {\n                response.headers[\"x-response-time\"] = \"\" + (stop - start);\n            }\n            return response;\n        });\n    };\n};\n\n/**\n * Decorates a Q-JSGI application such that all responses have the\n * given additional headers.  These headers do not override the\n * application's given response headers.\n *\n * @param {Object} headers\n * @param {App} app decorated application.\n */\nexports.Headers = function (app, headers) {\n    return function (request, response) {\n        return Q.when(app(request, response), function (response) {\n            if (response && response.headers) {\n                Object.keys(headers).forEach(function (key) {\n                    if (!(key in response.headers)) {\n                        response.headers[key] = headers[key];\n                    }\n                });\n            }\n            return response;\n        });\n    };\n};\n\nvar farFuture =\n    1000 * // ms\n    60 * // s\n    60 * // m\n    24 * // h\n    365 * // d\n    10; // years\nexports.Permanent = function (app, future) {\n    future = future || function () {\n        return new Date(new Date().getTime() + farFuture);\n    };\n    app = RouteApps.Tap(app, function (request, response) {\n        request.permanent = future;\n    });\n    app = RouteApps.Trap(app, function (response, request) {\n        response.headers[\"expires\"] = \"\" + future();\n    });\n    return app;\n};\n\n/**\n * Wraps a Q-JSGI application in a sequence of decorators.\n * @param {Array * Decorator} decorators\n * @param {App} app\n * @returns {App}\n */\nexports.Decorators = function (decorators, app) {\n    decorators.reversed().forEach(function (Middleware) {\n        app = Middleware(app);\n    });\n    return app;\n};","blocks":{"total":34,"seen":3,"missing":31,"percentage":0.08823529411764706}},"hash":"bfa5555807b1adf8a427de98fef4f22d"},"/Users/kris/q-io/http-apps/cookie.js":{"stats":{"percentage":0.8618421052631579,"lines":[{"lineno":21},{"lineno":22},{"lineno":33},{"lineno":39},{"lineno":48},{"lineno":81},{"lineno":86},{"lineno":89},{"lineno":90},{"lineno":114},{"lineno":115},{"lineno":116},{"lineno":117},{"lineno":118},{"lineno":120},{"lineno":131},{"lineno":132},{"lineno":135},{"lineno":143},{"lineno":144},{"lineno":145}],"missing":21,"seen":131,"total":152,"coverage":{"21":{"partial":true,"source":"                        if (cookie.expires && cookie.expires > now) {","missing":[{"startCol":46,"endCol":66}]},"22":{"partial":false,"source":"                            delete cookie[name];","missing":[{"startCol":28,"endCol":48}]},"33":{"partial":false,"source":"                        return [];","missing":[{"startCol":24,"endCol":34}]},"39":{"partial":false,"source":"                                return [];","missing":[{"startCol":32,"endCol":42}]},"48":{"partial":false,"source":"                                        request.ssl :","missing":[{"startCol":40,"endCol":51}]},"81":{"partial":false,"source":"                    response.headers[\"set-cookie\"] = [response.headers[\"set-cookie\"]];","missing":[{"startCol":20,"endCol":86}]},"86":{"partial":false,"source":"                        new Date();","missing":[{"startCol":24,"endCol":34}]},"89":{"partial":true,"source":"                    if (cookie.host && !hostContains(requestHost, cookie.host))","missing":[{"startCol":40,"endCol":78}]},"90":{"partial":false,"source":"                        delete cookie.host;","missing":[{"startCol":24,"endCol":43}]},"114":{"partial":false,"source":"        var parts = content.split(\".\");","missing":[{"startCol":8,"endCol":39},{"startCol":20,"endCol":38}]},"115":{"partial":false,"source":"        var hosts = [];","missing":[{"startCol":8,"endCol":23}]},"116":{"partial":false,"source":"        while (parts.length > 1) {","missing":[{"startCol":15,"endCol":31}]},"117":{"partial":false,"source":"            hosts.push(\".\" + parts.join(\".\"));","missing":[{"startCol":12,"endCol":45},{"startCol":23,"endCol":44},{"startCol":29,"endCol":44}]},"118":{"partial":false,"source":"            parts.shift();","missing":[{"startCol":12,"endCol":25}]},"120":{"partial":false,"source":"        return hosts;","missing":[{"startCol":8,"endCol":21}]},"131":{"partial":false,"source":"        ) || (","missing":[{}]},"132":{"partial":false,"source":"            container.slice(1) === content","missing":[{},{"startCol":12,"endCol":30}]},"133":{"partial":false,"source":"        );","missing":[{}]},"135":{"partial":false,"source":"        return container === content;","missing":[{"startCol":8,"endCol":37},{"startCol":15,"endCol":36}]},"143":{"partial":false,"source":"        return (","missing":[{}]},"144":{"partial":false,"source":"            content === container ||","missing":[{"startCol":12,"endCol":33},{}]},"145":{"partial":false,"source":"            content.indexOf(container + \"/\") === 0","missing":[{"startCol":12,"endCol":50},{},{"startCol":28,"endCol":43}]},"146":{"partial":false,"source":"        );","missing":[{}]}},"source":"var Q = require(\"q\");\nvar Cookie = require(\"../http-cookie\");\n\nexports.CookieJar = function (app) {\n    var hostCookies = {}; // to {} of pathCookies to [] of cookies\n    return function (request) {\n\n        var hosts = allHostsContaining(request.headers.host);\n\n        var now = new Date();\n\n        var requestCookies = concat(hosts.map(function (host) {\n\n            // delete expired cookies\n            for (var host in hostCookies) {\n                var pathCookies = hostCookies[host];\n                for (var path in pathCookies) {\n                    var cookies = pathCookies[path];\n                    for (var name in cookies) {\n                        var cookie = cookies[name];\n                        if (cookie.expires && cookie.expires > now) {\n                            delete cookie[name];\n                        }\n                    }\n                }\n            }\n\n            // collect applicable cookies\n            return concat(\n                Object.keys(hostCookies)\n                .map(function (host) {\n                    if (!hostContains(host, request.headers.host))\n                        return [];\n                    var pathCookies = hostCookies[host];\n                    return concat(\n                        Object.keys(pathCookies)\n                        .map(function (path) {\n                            if (!pathContains(path, request.path))\n                                return [];\n                            var cookies = pathCookies[path];\n                            return (\n                                Object.keys(cookies)\n                                .map(function (name) {\n                                    return cookies[name];\n                                })\n                                .filter(function (cookie) {\n                                    return cookie.secure ?\n                                        request.ssl :\n                                        true;\n                                })\n                            );\n                        })\n                    )\n                })\n            );\n\n        }));\n\n        if (requestCookies.length) {\n            request.headers[\"cookie\"] = (\n                requestCookies\n                .map(function (cookie) {\n                    return Cookie.stringify(\n                        cookie.key,\n                        cookie.value,\n                        cookie\n                    );\n                })\n                .join(\"; \")\n            );\n        }\n\n        return Q.when(app.apply(this, arguments), function (response) {\n            response.headers = response.headers || {};\n            if (response.headers[\"set-cookie\"]) {\n                var requestHost = ipRe.test(request.headers.host) ?\n                    request.headers.host :\n                    \".\" + request.headers.host;\n                // normalize to array\n                if (!Array.isArray(response.headers[\"set-cookie\"])) {\n                    response.headers[\"set-cookie\"] = [response.headers[\"set-cookie\"]];\n                }\n                response.headers[\"set-cookie\"].forEach(function (cookie) {\n                    var date = response.headers[\"date\"] ?\n                        new Date(response.headers[\"date\"]) :\n                        new Date();\n                    cookie = Cookie.parse(cookie, date);\n                    // ignore illegal host\n                    if (cookie.host && !hostContains(requestHost, cookie.host))\n                        delete cookie.host;\n                    var host = requestHost || cookie.host;\n                    var path = cookie.path || \"/\";\n                    var pathCookies = hostCookies[host] = hostCookies[host] || {};\n                    var cookies = pathCookies[path] = pathCookies[path] || {};\n                    cookies[cookie.key] = cookie;\n                })\n                delete response.headers[\"set-cookie\"];\n            }\n\n            return response;\n        });\n\n    };\n};\n\nvar ipRe = /^\\d+\\.\\d+\\.\\d+\\.\\d+$/;\n\nfunction allHostsContaining(content) {\n    if (ipRe.test(content)) {\n        return [content];\n    } if (content === \"localhost\") {\n        return [content];\n    } else {\n        var parts = content.split(\".\");\n        var hosts = [];\n        while (parts.length > 1) {\n            hosts.push(\".\" + parts.join(\".\"));\n            parts.shift();\n        }\n        return hosts;\n    }\n}\n\nfunction hostContains(container, content) {\n    if (ipRe.test(container) || ipRe.test(content)) {\n        return container === content;\n    } else if (/^\\./.test(container)) {\n        return (\n            content.lastIndexOf(container) ===\n            content.length - container.length\n        ) || (\n            container.slice(1) === content\n        );\n    } else {\n        return container === content;\n    }\n};\n\nfunction pathContains(container, content) {\n    if (/^\\/$/.test(container)) {\n        return content.indexOf(container) === 0;\n    } else {\n        return (\n            content === container ||\n            content.indexOf(container + \"/\") === 0\n        );\n    }\n}\n\nfunction concat(arrays) {\n    return [].concat.apply([], arrays);\n}","blocks":{"total":33,"seen":24,"missing":9,"percentage":0.7272727272727273}},"hash":"33725c22c2ca23d92792a9778c39f9f8"},"/Users/kris/q-io/http-cookie.js":{"stats":{"percentage":0.7945205479452054,"lines":[{"lineno":27},{"lineno":29},{"lineno":31},{"lineno":32},{"lineno":33},{"lineno":36},{"lineno":37},{"lineno":38},{"lineno":41},{"lineno":43},{"lineno":62},{"lineno":64},{"lineno":66},{"lineno":68},{"lineno":70}],"missing":15,"seen":58,"total":73,"coverage":{"27":{"partial":false,"source":"            parsed.domain = value;","missing":[{"startCol":12,"endCol":34}]},"29":{"partial":false,"source":"            parsed.path = value;","missing":[{"startCol":12,"endCol":32}]},"31":{"partial":false,"source":"            parsed.expires = new Date(","missing":[{}]},"32":{"partial":false,"source":"                +new Date() + // actual now","missing":[{}]},"33":{"partial":false,"source":"                (new Date(value) - date) // server offset","missing":[{},{"startCol":16,"endCol":40}]},"34":{"partial":false,"source":"            );","missing":[{}]},"36":{"partial":false,"source":"            parsed.expires = new Date(","missing":[{}]},"37":{"partial":false,"source":"                new Date().getTime() +","missing":[{},{"startCol":16,"endCol":36}]},"38":{"partial":false,"source":"                (value * 1000)","missing":[{"startCol":16,"endCol":30},{}]},"39":{"partial":false,"source":"            );","missing":[{}]},"41":{"partial":false,"source":"            parsed.secure = true;","missing":[{"startCol":12,"endCol":33}]},"43":{"partial":false,"source":"            parsed.httpOnly = true;","missing":[{"startCol":12,"endCol":35}]},"62":{"partial":false,"source":"            cookie += \"; Domain=\" + encodeURIComponent(options.domain);","missing":[{"startCol":12,"endCol":71},{"startCol":22,"endCol":70},{"startCol":36,"endCol":70}]},"64":{"partial":false,"source":"            cookie += \"; Path=\" + encodeURIComponent(options.path);","missing":[{"startCol":12,"endCol":67},{"startCol":22,"endCol":66},{"startCol":34,"endCol":66}]},"66":{"partial":false,"source":"            cookie += \"; Expires=\" + options.expires.toGMTString();","missing":[{"startCol":12,"endCol":67},{"startCol":22,"endCol":66},{"startCol":37,"endCol":66}]},"68":{"partial":false,"source":"            cookie += \"; Secure\";","missing":[{"startCol":12,"endCol":33}]},"70":{"partial":false,"source":"            cookie += \"; HttpOnly\";","missing":[{"startCol":12,"endCol":35}]}},"source":"/**\n * Provides utilities for reading and writing HTTP cookies.\n * @module\n */\n\n/*whatsupdoc*/\n\nvar QS = require(\"qs\");\n\n/**\n * @param {String} cookie\n * @returns {Object}\n */\nexports.parse = function (cookie, date) {\n    date = date || new Date();\n    var parsed = {};\n    var terms = cookie.split(/[;,]/g);\n    var keyValue = terms.shift().split(\"=\");\n    parsed.key = keyValue[0];\n    parsed.value = keyValue[1];\n    terms.forEach(function (term) {\n        var parts = term.split(\"=\").map(function (part) {\n            return part.trim();\n        });\n        var key = parts[0], value = parts[1];\n        if (/^domain$/i.test(key)) {\n            parsed.domain = value;\n        } else if (/^path$/i.test(key)) {\n            parsed.path = value;\n        } else if (/^expires$/i.test(key)) {\n            parsed.expires = new Date(\n                +new Date() + // actual now\n                (new Date(value) - date) // server offset\n            );\n        } else if (/^max-age$/i.test(key)) {\n            parsed.expires = new Date(\n                new Date().getTime() +\n                (value * 1000)\n            );\n        } else if (/^secure$/i.test(key)) {\n            parsed.secure = true;\n        } else if (/^httponly$/i.test(key)) {\n            parsed.httpOnly = true;\n        }\n    });\n    return parsed;\n};\n\n/**\n * @param {String} key\n * @param {String} value\n * @param {Object} options (optional)\n * @returns {String} a cookie string\n */\nexports.stringify = function (key, value, options) {\n    var cookie = (\n        encodeURIComponent(key) + \"=\" +\n        encodeURIComponent(value)\n    );\n    if (options) {\n        if (options.domain)\n            cookie += \"; Domain=\" + encodeURIComponent(options.domain);\n        if (options.path)\n            cookie += \"; Path=\" + encodeURIComponent(options.path);\n        if (options.expires)\n            cookie += \"; Expires=\" + options.expires.toGMTString();\n        if (options.secure)\n            cookie += \"; Secure\";\n        if (options.httpOnly)\n            cookie += \"; HttpOnly\";\n    }\n    return cookie;\n};","blocks":{"total":16,"seen":5,"missing":11,"percentage":0.3125}},"hash":"add1cd67243c5d988b19e141c38f2fd9"},"/Users/kris/q-io/spec/http-apps/directory-list-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":84,"total":84,"coverage":{},"source":"require(\"../lib/jasmine-promise\");\nvar Http = require(\"../../http\");\nvar Apps = require(\"../../http-apps\");\nvar FS = require(\"../../fs\");\n\ndescribe(\"directory lists\", function () {\n\n    it(\"should be fine in plain text\", function () {\n\n        var fixture = FS.join(module.directory || __dirname, \"fixtures\");\n\n        var app = new Apps.Chain()\n        .use(Apps.Cap)\n        .use(Apps.ListDirectories)\n        .use(function () {\n            return Apps.FileTree(fixture);\n        })\n        .end()\n\n        return Http.Server(app)\n        .listen(0)\n        .then(function (server) {\n            var port = server.address().port;\n            return Http.read({\n                url: \"http://127.0.0.1:\" + port + \"/\",\n                headers: {\n                    accept: \"text/plain\"\n                },\n                charset: 'utf-8'\n            })\n            .then(function (content) {\n                expect(content).toEqual(\"1234.txt\\n5678.txt\\n9012/\\n\");\n            })\n            .finally(server.stop);\n        });\n\n    });\n\n    it(\"should be fine in html\", function () {\n\n        var fixture = FS.join(module.directory || __dirname, \"fixtures\");\n\n        var app = new Apps.Chain()\n        .use(Apps.Cap)\n        .use(Apps.HandleHtmlFragmentResponses)\n        .use(Apps.ListDirectories)\n        .use(function () {\n            return Apps.FileTree(fixture);\n        })\n        .end()\n\n        return Http.Server(app)\n        .listen(0)\n        .then(function (server) {\n            var port = server.address().port;\n            return Http.read({\n                url: \"http://127.0.0.1:\" + port + \"/\",\n                headers: {\n                    accept: \"text/html\"\n                },\n                charset: 'utf-8'\n            })\n            .then(function (content) {\n                expect(content).toEqual(\n                    \"<!doctype html>\\n\" +\n                    \"<html>\\n\" +\n                    \"    <head>\\n\" +\n                    \"        <title>Directory Index</title>\\n\" +\n                    \"    </head>\\n\" +\n                    \"    <body>\\n\" +\n                    \"        <ul class=\\\"directory-index\\\">\\n\" +\n                    \"            <li class=\\\"entry file\\\"><a href=\\\"1234.txt\\\">1234.txt</a></li>\\n\" +\n                    \"            <li class=\\\"entry file\\\"><a href=\\\"5678.txt\\\">5678.txt</a></li>\\n\" +\n                    \"            <li class=\\\"entry directory\\\"><a href=\\\"9012/\\\">9012/</a></li>\\n\" +\n                    \"        </ul>\\n\" +\n                    \"    </body>\\n\" +\n                    \"</html>\\n\"\n                );\n            })\n            .finally(server.stop);\n        });\n\n    });\n});","blocks":{"total":9,"seen":9,"missing":0,"percentage":1}},"hash":"773505ab280b6af9bda9bae61302d6a8"},"/Users/kris/q-io/spec/http-apps/interpret-range-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":50,"total":50,"coverage":{},"source":"// http://labs.apache.org/webarch/http/draft-fielding-http/p5-range.html#range.units\n\nvar Apps = require(\"../../http-apps/fs\");\n\nvar size = 10000;\nvar tests = [\n    {\n        description: \"The first 500 bytes (byte offsets 0-499, inclusive)\",\n        input: \"bytes=0-499\",\n        oracle: {begin: 0, end: 500}\n    },\n    {\n        description: \"The second 500 bytes (byte offsets 500-999, inclusive)\",\n        input: \"bytes=500-999\",\n        oracle: {begin: 500, end: 1000}\n    },\n    {\n        description: \"The final 500 bytes (byte offsets 9500-9999, inclusive)\",\n        input: \"bytes=-500\",\n        oracle: {begin: 9500, end: 10000}\n    },\n    {\n        description: \"The final 500 bytes (byte offsets 9500-9999, inclusive)\",\n        input: \"bytes=9500-\",\n        oracle: {begin: 9500, end: 10000}\n    },\n    {\n        description: \"The first and last bytes only (bytes 0 and 9999)\",\n        input: \"bytes=0-0,-1\",\n        oracle: {begin: 0, end: 1}\n    },\n    {\n        description: \"Legal but not canonical specification of the second 500 bytes (byte offsets 500-999, inclusive)\",\n        input: \"bytes=500-600,601-999\",\n        oracle: {begin: 500, end: 1000}\n    },\n    {\n        description: \"Legal but not canonical specification of the second 500 bytes (byte offsets 500-999, inclusive)\",\n        input: \"bytes=500-700,601-999\",\n        oracle: {begin: 500, end: 1000}\n    }\n];\n\ndescribe(\"range interpretation\", function () {\n    tests.forEach(function (test) {\n        it(\"should interpret \" + test.input, function () {\n            expect(Apps.interpretFirstRange(test.input, size)).toEqual(test.oracle);\n        });\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"ffb2be436f859e596e20e474a4c61500"},"/Users/kris/q-io/spec/http-apps/partial-range-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":38,"total":38,"coverage":{},"source":"require(\"../lib/jasmine-promise\");\nvar Http = require(\"../../http\");\nvar Apps = require(\"../../http-apps\");\nvar FS = require(\"../../fs\");\n\ndescribe(\"http client and server apps\", function () {\n\n    it(\"should read a partial range\", function () {\n\n        var fixture = FS.join(module.directory || __dirname, \"fixtures\", \"1234.txt\");\n\n        var app = new Apps.Chain()\n        .use(Apps.Cap)\n        .use(function () {\n            return Apps.File(fixture);\n        })\n        .end()\n\n        return Http.Server(app)\n        .listen(0)\n        .then(function (server) {\n            var port = server.node.address().port;\n            return Http.read({\n                \"url\": \"http://127.0.0.1:\" + port + \"/\",\n                \"headers\": {\n                    \"range\": \"bytes=1-2\"\n                }\n            }, function (response) {\n                return response.status === 206;\n            })\n            .then(function (content) {\n                expect(content.toString('utf-8')).toEqual('23');\n            })\n            .finally(server.stop)\n        })\n    });\n\n});","blocks":{"total":6,"seen":6,"missing":0,"percentage":1}},"hash":"a2f0a7b4060e64887b0271376c3dfcba"},"/Users/kris/q-io/spec/http-apps/proxy-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":80,"total":80,"coverage":{},"source":"require(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar Http = require(\"../../http\");\nvar Apps = require(\"../../http-apps\");\nvar FS = require(\"../../fs\");\n\ndescribe(\"http proxy\", function () {\n\n    it(\"should work\", function () {\n\n        var requestProxy;\n        var responseProxy;\n        var requestActual;\n        var responseActual;\n\n        var app = Apps.Chain()\n        .use(Apps.Trap, function (response) {\n            responseActual = response;\n            return response;\n        })\n        .use(Apps.Tap, function (request) {\n            requestActual = request;\n        })\n        .use(function (next) {\n            return Apps.Branch({\n                \"foo\": Apps.Branch({\n                    \"bar\": new Apps.Chain()\n                        .use(Apps.Cap)\n                        .use(function () {\n                            return Apps.Content([\"Hello, World!\"])\n                        })\n                        .end()\n                })\n            })\n        })\n        .end();\n\n        var server1 = Http.Server(app);\n\n        return Q.when(server1.listen(0))\n        .then(function (server1) {\n            var port = server1.node.address().port;\n\n            var server2 = Http.Server(\n                Apps.Trap(\n                    Apps.Tap(\n                        Apps.ProxyTree(\"http://127.0.0.1:\" + port + \"/foo/\"),\n                        function (request) {\n                            requestProxy = request;\n                        }\n                    ),\n                    function (response) {\n                        responseProxy = response;\n                        return response;\n                    }\n                )\n            );\n\n            return [server1, server2.listen(0)];\n        })\n        .spread(function (server1, server2) {\n            var port = server2.node.address().port;\n            return Http.read({\n                url: \"http://127.0.0.1:\" + port + \"/bar\",\n                charset: \"utf-8\"\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\");\n                expect(requestActual).toBeTruthy();\n                expect(responseActual).toBeTruthy();\n                expect(requestProxy).toBeTruthy();\n                expect(responseProxy).toBeTruthy();\n            })\n            .finally(server1.stop)\n            .finally(server2.stop)\n        })\n\n    });\n\n});","blocks":{"total":11,"seen":11,"missing":0,"percentage":1}},"hash":"60e0c340498b7532496130605a9b5256"},"/Users/kris/q-io/spec/http/basic-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":94,"total":94,"coverage":{},"source":"require(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar HTTP = require(\"../../http\");\n\ndescribe(\"http server and client\", function () {\n\n    it(\"should work as both server and client\", function () {\n        var response = {\n            \"status\": 200,\n            \"headers\": {\n                \"content-type\": \"text/plain\"\n            },\n            \"body\": [\n                \"Hello, World!\"\n            ]\n        };\n\n        var server = HTTP.Server(function () {\n            return response;\n        });\n\n        return server.listen(0)\n        .then(function (server) {\n            var port = server.address().port;\n\n            var request = {\n                \"host\": \"localhost\",\n                \"port\": port,\n                \"headers\": {\n                    \"host\": \"localhost\"\n                }\n            };\n\n            return HTTP.request(request)\n            .then(function (response) {\n                expect(Q.isPromise(response.body)).toBe(false);\n                var acc = [];\n                return response.body.read()\n                .then(function (body) {\n                    expect(body.toString(\"utf-8\")).toBe(\"Hello, World!\");\n                });\n            })\n        })\n        .finally(server.stop)\n    });\n\n    it(\"should defer a response\", function () {\n        var response = {\n            \"status\": 200,\n            \"headers\": {\n                \"content-type\": \"text/plain; charset=utf-8\"\n            },\n            \"body\": {\n                \"forEach\": function (write) {\n                    var deferred = Q.defer();\n                    write(\"Hello, World!\");\n                    setTimeout(function () {\n                        deferred.resolve();\n                    }, 100);\n                    return deferred.promise;\n                }\n            }\n        };\n\n        var server = HTTP.Server(function () {\n            return response;\n        });\n\n        return server.listen(0).then(function (server) {\n            var port = server.node.address().port;\n\n            var request = {\n                \"host\": \"localhost\",\n                \"port\": port,\n                \"headers\": {\n                    \"host\": \"localhost\"\n                },\n                \"charset\": \"utf-8\"\n            };\n\n            return HTTP.request(request)\n            .then(function (response) {\n                var acc = [];\n                return response.body.read()\n                .then(function (body) {\n                    expect(body).toBe(\"Hello, World!\");\n                });\n            })\n        })\n        .finally(server.stop)\n    });\n\n\n});","blocks":{"total":13,"seen":13,"missing":0,"percentage":1}},"hash":"0b156f3941f2baa80698b59e4b341a6d"}}}