{
  "name": "rrule",
  "version": "2.0.0",
  "description": "JavaScript library for working with recurrence rules for calendar dates.",
  "homepage": "https://github.com/jkbr/rrule",
  "keywords": [
    "dates",
    "recurrences",
    "calendar",
    "icalendar",
    "rfc"
  ],
  "author": {
    "name": "Jakub Roztocil and Lars Schöning"
  },
  "main": "lib/rrule",
  "repository": {
    "type": "git",
    "url": "git://github.com/jkbr/rrule.git"
  },
  "dependencies": {
    "underscore": ">= 1.3.3"
  },
  "readme": "rrule.js\n========\n\n**Library for working with recurrence rules for calendar dates.**\n\nrrule.js supports recurrence rules as defined in the [iCalendar\nRFC](http://www.ietf.org/rfc/rfc2445.txt). It is a partial port of the\n`rrule` module from the excellent\n[python-dateutil](http://labix.org/python-dateutil/) library. On top of\nthat, it supports parsing and serialization of recurrence rules from and\nto natural language.\n\nThe only dependency is [Underscore.js](http://underscorejs.org/).\n\n* * * * *\n\n\n### Quick Start\n\n-   [Demo app](http://jkbr.github.io/rrule/)\n-   [Test suite](http://jkbr.github.io/rrule/tests/index.html)\n\n\n#### Client Side\n\nDownload\n[rrule.js](https://raw.github.com/jkbr/rrule/master/lib/rrule.js). If\nyou want to use `RRule.prototype.toText()` or `RRule.fromText()`, you'll\nalso need [nlp.js](https://raw.github.com/jkbr/rrule/master/lib/nlp.js).\n\n```html\n<script src=\"underscore.js\"></script>\n<script src=\"rrule/lib/rrule.js\"></script>\n\n<!-- Optional -->\n<script src=\"rrule/lib/nlp.js\"></script>\n```\n\n#### Server Side\n\n```bash\n$ npm install rrule\n```\n\n```javascript\nvar RRule = require('rrule').RRule;\n```\n\n#### Usage\n\n```javascript\n// Create a rule:\nvar rule = new RRule({\n    freq: RRule.WEEKLY,\n    interval: 5,\n    byweekday: [RRule.MO, RRule.FR],\n    dtstart: new Date(2012, 1, 1, 10, 30),\n    until: new Date(2012, 12, 31)\n});\n\n// Get all occurrence dates (Date instances):\nrule.all();\n['Fri Feb 03 2012 10:30:00 GMT+0100 (CET)',\n 'Mon Mar 05 2012 10:30:00 GMT+0100 (CET)',\n 'Fri Mar 09 2012 10:30:00 GMT+0100 (CET)',\n 'Mon Apr 09 2012 10:30:00 GMT+0200 (CEST)',\n /* … */]\n\n// Get a slice:\nrule.between(new Date(2012, 7, 1), new Date(2012, 8, 1))\n['Mon Aug 27 2012 10:30:00 GMT+0200 (CEST)',\n 'Fri Aug 31 2012 10:30:00 GMT+0200 (CEST)']\n\n// Get an iCalendar RRULE string representation:\n// The output can be used with RRule.fromString().\nrule.toString();\n\"FREQ=WEEKLY;DTSTART=20120201T093000Z;INTERVAL=5;UNTIL=20130130T230000Z;BYDAY=MO,FR\"\n\n// Get a human-friendly text representation:\n// The output can be used with RRule.fromText().\nrule.toText()\n\"every 5 weeks on Monday, Friday until January 31, 2013\"\n```\n\nFor more examples see\n[tests/tests.js](https://github.com/jkbr/rrule/blob/master/tests/tests.js)\nand [python-dateutil](http://labix.org/python-dateutil/) documentation.\n\n### API\n\n#### `RRule` Constructor\n\n```javascript\nnew RRule(options[, noCache=false])\n```\n\nThe `options` argument mostly corresponds to the properties defined for `RRULE` in the\niCalendar RFC. Only `freq` is required.\n\n<table>\n    <!-- why, markdown... -->\n    <thead>\n    <tr>\n        <th>Option</th>\n        <th>Description</th>\n    </tr>\n    <thead>\n    <tbody>\n    <tr>\n        <td><code>freq</code></td>\n        <td>\n            <p>(required) One of the following constants:</p>\n            <ul>\n                <li><code>RRule.YEARLY</code></li>\n                <li><code>RRule.MONTHLY</code></li>\n                <li><code>RRule.WEEKLY</code></li>\n                <li><code>RRule.DAILY</code></li>\n                <li><code>RRule.HOURLY</code></li>\n                <li><code>RRule.MINUTELY</code></li>\n                <li><code>RRule.SECONDLY</code></li>\n            </ul>\n        </td>\n    </tr>\n    <tr>\n        <td><code>dtstart</code></td>\n        <td>The recurrence start. Besides being the base for the\n            recurrence, missing parameters in the final recurrence\n            instances will also be extracted from this date. If not\n            given, <code>new Date</code> will be used instead.\n        </td>\n    </tr>\n    <tr>\n        <td><code>interval</code></td>\n        <td>The interval between each freq iteration. For example,\n            when using <code>RRule.YEARLY</code>, an interval of <code>2</code> means\n            once every\n            two years, but with <code>RRule.HOURLY</code>, it means once every two\n            hours.\n            The default interval is <code>1</code>.\n        </td>\n    </tr>\n    <tr>\n        <td><code>wkst</code></td>\n        <td>The week start day. Must be one of the <code>RRule.MO</code>,\n            <code>RRule.TU</code>, <code>RRule.WE</code> constants, or an integer,\n            specifying\n            the first day of the week. This will affect recurrences based\n            on weekly periods. The default week start is <code>RRule.MO</code>.\n        </td>\n    </tr>\n    <tr>\n        <td><code>count</code></td>\n        <td>How many occurrences will be generated.</td>\n    </tr>\n    <tr>\n        <td><code>until</code></td>\n        <td>If given, this must be a <code>Date</code> instance, that will specify\n            the limit of the recurrence. If a recurrence instance happens\n            to be the same as the <code>Date</code> instance given in the\n            <code>until</code>\n            argument, this will be the last occurrence.\n        </td>\n    </tr>\n    <tr>\n        <td><code>bysetpos</code></td>\n        <td>If given, it must be either an integer, or a sequence of\n            integers, positive or negative. Each given integer will specify\n            an occurrence number, corresponding to the nth occurrence of\n            the rule inside the frequency period. For example, a\n            <code>bysetpos</code> of <code>-1</code> if combined with a <code>RRule.MONTHLY</code>\n            frequency, and a byweekday of (<code>RRule.MO</code>, <code>RRule.TU</code>,\n            <code>RRule.WE</code>, <code>RRule.TH</code>, <code>FR</code>), will result in\n            the last\n            work day of every month.\n        </td>\n    </tr>\n    <tr>\n        <td><code>bymonth</code></td>\n        <td>If given, it must be either an integer, or a sequence of\n            integers, meaning the months to apply the recurrence to.\n        </td>\n    </tr>\n    <tr>\n        <td><code>bymonthday</code></td>\n        <td>If given, it must be either an integer, or a sequence of\n            integers, meaning the month days to apply the recurrence to.\n        </td>\n    </tr>\n    <tr>\n        <td><code>byyearday</code></td>\n        <td>If given, it must be either an integer, or a sequence of\n            integers, meaning the year days to apply the recurrence to.\n        </td>\n    </tr>\n    <tr>\n        <td><code>byweekno</code></td>\n        <td>If given, it must be either an integer, or a sequence of\n            integers, meaning the week numbers to apply the recurrence to.\n            Week numbers have the meaning described in ISO8601, that is,\n            the first week of the year is that containing at least four\n            days of the new year.\n        </td>\n    </tr>\n    <tr>\n        <td><code>byweekday</code></td>\n        <td>If given, it must be either an integer (<code>0 == RRule.MO</code>), a\n            sequence of integers, one of the weekday constants\n            (<code>RRule.MO</code>,\n            <code>RRule.TU</code>, etc), or a sequence of these constants. When\n            given,\n            these variables will define the weekdays where the recurrence\n            will be applied. It's also possible to use an argument n for\n            the weekday instances, which will mean the nth occurrence of\n            this weekday in the period. For example, with\n            <code>RRule.MONTHLY</code>,\n            or with <code>RRule.YEARLY</code> and <code>BYMONTH</code>, using\n            <code>RRule.FR.nth(+1)</code> or <code>RRule.FR.nth(-1)</code> in <code>byweekday</code>\n            will specify the first or last friday of the month where the\n            recurrence happens.\n            Notice\n            that the RFC documentation, this is specified as <code>BYDAY</code>,\n            but was renamed to avoid the ambiguity of that argument.\n        </td>\n    </tr>\n    <tr>\n        <td><code>byhour</code></td>\n        <td>If given, it must be either an integer, or a sequence of\n            integers, meaning the hours to apply the recurrence to.\n        </td>\n    </tr>\n    <tr>\n        <td><code>byminute</code></td>\n        <td>If given, it must be either an integer, or a sequence of\n            integers, meaning the minutes to apply the recurrence to.\n        </td>\n    </tr>\n    <tr>\n        <td><code>bysecond</code></td>\n        <td>If given, it must be either an integer, or a sequence of\n            integers, meaning the seconds to apply the recurrence to.\n        </td>\n    </tr>\n    <tr>\n        <td><code>byeaster</code></td>\n        <td>This is an extension to the RFC specification which the Python\n            implementation provides.\n            <strong>Not implemented in the JavaScript version.</strong>\n        </td>\n    </tr>\n    </tbody>\n</table>\n\n\n`noCache`: Set to `true` to disable caching of results. If you will use the\nsame rrule instance multiple times, enabling caching will improve the\nperformance considerably. Enabled by default.\n\nSee also [python-dateutil](http://labix.org/python-dateutil/)\ndocumentation.\n\n\n* * * * *\n\n\n#### Instance properties\n\n<dl>\n    <dt><code>rule.options</code></dt>\n    <dd>Processed options applied to the rule. Includes default options\n    (such us `wkstart`). Currently, `rule.options.byweekday` isn't equal\n    to `rule.origOptions.byweekday` (which is an inconsistency).</dd>\n\n    <dt><code>rule.origOptions</code></dt>\n    <dd>The original <code>options</code> argument passed to\n    the constructor.</dd>\n</dl>\n\n\n* * * * *\n\n\n#### Occurrence Retrieval Methods\n\n##### `RRule.prototype.all([iterator])`\n\nReturns all dates matching the rule. It is a replacement for the\niterator protocol this class implements in the Python version.\n\nAs rules without `until` or `count` represent infinite date series, you\ncan optionally pass `iterator`, which is a function that is called for\neach date matched by the rule. It gets two parameters `date` (the `Date`\ninstance being added), and `i` (zero-indexed position of `date` in the\nresult). Dates are being added to the result as long as the iterator\nreturns `true`. If a `false`-y value is returned, `date` isn't added to\nthe result and the iteration is interrupted (possibly prematurely).\n\n```javascript\nrule.all()\n['Fri Feb 03 2012 10:30:00 GMT+0100 (CET)',\n 'Mon Mar 05 2012 10:30:00 GMT+0100 (CET)',\n 'Fri Mar 09 2012 10:30:00 GMT+0100 (CET)',\n 'Mon Apr 09 2012 10:30:00 GMT+0200 (CEST)',\n /* … */]\n\nrule.all(function (date, i){return i < 2});\n['Fri Feb 03 2012 10:30:00 GMT+0100 (CET)',\n 'Mon Mar 05 2012 10:30:00 GMT+0100 (CET)',]\n```\n\n##### `RRule.prototype.between(after, before, inc=false [, iterator])`\n\nReturns all the occurrences of the rrule between `after` and `before`.\nThe inc keyword defines what happens if `after` and/or `before` are\nthemselves occurrences. With `inc == true`, they will be included in the\nlist, if they are found in the recurrence set.\n\nOptional `iterator` has the same function as it has with\n`RRule.prototype.all()`.\n\n```javascript\nrule.between(new Date(2012, 7, 1), new Date(2012, 8, 1))\n['Mon Aug 27 2012 10:30:00 GMT+0200 (CEST)',\n 'Fri Aug 31 2012 10:30:00 GMT+0200 (CEST)']\n```\n\n##### `RRule.prototype.after(dt, inc=false)`\n\nReturns the last recurrence before the given `Date` instance. The `inc`\nargument defines what happens if `dt` is an occurrence. With\n`inc == true`, if `dt` itself is an occurrence, it will be returned.\n\n\n##### `RRule.prototype.before(dt, inc=false)`\n\nReturns the last recurrence\nafter the given `Date` instance. The `inc` argument defines what happens\nif `dt` is an occurrence. With `inc == true`, if `dt` itself is an\noccurrence, it will be returned.\n\nSee also [python-dateutil](http://labix.org/python-dateutil/)\ndocumentation.\n\n\n* * * * *\n\n\n#### iCalendar RFC String Methods\n\n##### `RRule.prototype.toString()`\n\nReturns a string representation of the rule as per the iCalendar RFC.\nOnly properties explicitely specified in `options` are included:\n\n```javascript\nrule.toString();\n\"FREQ=WEEKLY;DTSTART=20120201T093000Z;INTERVAL=5;UNTIL=20130130T230000Z;BYDAY=MO,FR\"\n\nrule.toString() == RRule.optionsToString(rule.origOptions)\ntrue\n```\n\n##### `RRule.optionsToString(options)`\n\nConverts `options` to iCalendar RFC `RRULE` string:\n\n```javascript\n// Get full a string representation of all options,\n// including the default and inferred ones.\nRRule.optionsToString(rule.options)\n\"FREQ=WEEKLY;DTSTART=20120201T093000Z;INTERVAL=5;WKST=0;UNTIL=20130130T230000Z;BYDAY=MO,FR;BYHOUR=10;BYMINUTE=30;BYSECOND=0\"\n\n// Cherry-pick only some options from an rrule:\nRRule.optionsToString({\n    freq: rule.options.freq,\n    dtstart: rule.options.dtstart,\n})\n\"FREQ=WEEKLY;DTSTART=20120201T093000Z\"\n```\n\n##### `RRule.fromString(rfcString)`\n\nConstructs an `RRule` instance from a complete `rfcString`:\n\n```javascript\nvar rule = RRule.fromString(\"FREQ=WEEKLY;DTSTART=20120201T093000Z\")\n\n// This is equivalent\nvar rule = new RRule(RRule.parseString(\"FREQ=WEEKLY;DTSTART=20120201T093000Z\"))\n```\n\n##### `RRule.parseString(rfcString)`\n\nOnly parse RFC string and return `options`.\n\n```javascript\nvar options = RRule.parseString('FREQ=DAY;INTERVAL=6')\noptions.dtstart = new Date(2000, 1, 1)\nvar rule = new RRule(options)\n```\n\n* * * * *\n\n#### Natural Language Text Methods\n\nThese methods provide an incomplete support for text–`RRule` and\n`RRule`–text conversion. You should test them with your input to see\nwhether the result is acceptable.\n\nTo use these methods in the browser, you need to include the\n`rrule/nlp.js` file as well.\n\n##### `RRule.prototype.toText([gettext, [language]])`\n\nReturns a textual representation of `rule`. The `gettext` callback, if\nprovided, will be called for each text token and its return value used\ninstead. The optional `language` argument is a language definition to be\nused (defaults to `rrule/nlp.js:ENGLISH`).\n\n```javascript\nvar rule = new RRule({\n  freq: RRule.WEEKLY,\n  count: 23\n})\nrule.toText()\n\"every week for 23 times\"\n```\n\n##### `RRule.prototype.isFullyConvertibleToText()`\n\nProvides a hint on whether all the options the rule has are convertible\nto text.\n\n##### `RRule.fromText(text[, language])`\n\nConstructs an `RRule` instance from `text`.\n\n```javascript\nrule = RRule.fromText('every day for 3 times')\n```\n\n##### `RRule.parseText(text[, language])`\n\nParse `text` into `options`:\n\n```javascript\noptions = RRule.parseText('every day for 3 times')\n// {freq: 3, count: \"3\"}\noptions.dtstart = new Date(2000, 1, 1)\nvar rule = new RRule(options)\n```\n\n* * * * *\n\n### Changelog\n\n* 2.0.0 (2013-07-16)\n   * Fixed a February 28-related issue.\n   * More flexible, backwards-incompatible API:\n      * `freq` is now `options.freq`.\n      * `options.cache` is now `noCache`.\n      * `iterator` has to return `true`\n      * `dtstart` and `options` arguments removed from `RRule.fromString`\n        (use `RRule.parseString` and modify `options` manually instead).\n      * `today` argument removed from `Rule.prototype.toText`\n        (never actually used).\n      * `rule.toString()` now includes `DTSTART` (if explicitely specified\n        in `options`).\n      * Day constants `.clone` is now `.nth`, eg. `RRule.FR.nth(-1)`\n        (last Friday).\n   * Added `RRule.parseString`\n   * Added `RRule.parseText`\n   * Added `RRule.optionsToString`\n* 1.1.0 (2013-05-21)\n   * Added a [demo app](http://jkbr.github.io/rrule/).\n   * Handle dates in `UNTIL` in `RRule.fromString`.\n   * Added support for RequireJS.\n   * Added `options` argument to `RRule.fromString`.\n* 1.0.1 (2013-02-26)\n   * Fixed leap years (thanks @jessevogt)\n* 1.0.0 (2013-01-24)\n   * Fixed timezone offset issues related to DST (thanks @evro).\n* 1.0.0-beta (2012-08-15)\n   * Initial public release.\n\n\n#### Authors\n\n* [Jakub Roztocil](http://roztocil.name/)\n    ([@jakubroztocil](http://twitter.com/jakubroztocil))\n* Lars Schöning ([@lyschoening](http://twitter.com/lyschoening))\n\nPython `dateutil` is written by [Gustavo\nNiemeyer](http://niemeyer.net/).\n\nSee [LICENCE](https://github.com/jkbr/rrule/blob/master/LICENCE) for\nmore details.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jkbr/rrule/issues"
  },
  "_id": "rrule@2.0.0",
  "dist": {
    "shasum": "c54a75ffc88671dd72fe459556a6bcf6cf2cf26e"
  },
  "_from": "rrule@2.0.0",
  "_resolved": "https://registry.npmjs.org/rrule/-/rrule-2.0.0.tgz"
}
